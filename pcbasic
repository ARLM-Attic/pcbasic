#!/usr/bin/env python

#
# PC-BASIC 3.23 
#
# GW-BASIC (R) compatible interpreter 
# 
# (c) 2013, 2014 Rob Hagemans 
#
# This file is released under the GNU GPL version 3. 
# please see text file COPYING for licence terms.
#
# GW-BASIC is a trademark of Microsoft Corporation.

import sys
import os
from functools import partial

import plat

# do we log to a file? 
logfile = ''

import logging

import config
import run
import error
import oslayer
import unicodepage
import console
import backend
import novideo
import backend_cli
import sound
import nosound
import nopenstick
import program
import state
import iolayer
import var

greeting = 'PC-BASIC 3.23%s\r(C) Copyright 2013, 2014 PC-BASIC authors. Type RUN "@:INFO" for more.\r%d Bytes free\rOk\xff'


def main():
    """ Initialise and do operations or hand over to run module. """
    reset = False
    resume = None
    # logging setup
    prepare_logging()
    try:
        # ignore resume option in converter mode
        if config.options['resume'] and not config.options['conv']:
            # resume from saved emulator state
            resume = state.load()
        # choose the video and sound backends
        prepare_console()
        # in convertor mode, convert and exit
        if config.options['conv']:
            convert()
            raise error.Exit()
        # ignore load and run options in resume mode    
        if not resume:    
            # print greeting
            print_greeting()
            # load any program    
            load_program()
            # run commands and programs
            run_commands()
        # start the interpreter loop
        # and get out, if we ran with -q
        run.loop(config.options['quit'])
    except error.RunError as e:
        # errors during startup/conversion are handled here, then exit
        logging.error(error.get_message(e.err))
    except error.Exit:
        pass
    except error.Reset:
        reset = True
    except KeyboardInterrupt:
        if config.options['debug']:
            raise
    finally:
        # do not save state if converting, delete state if resetting 
        if reset:
            state.delete()
        elif not config.options['conv']:   
            state.save()
        # fix the terminal on exit or crashes (inportant for ANSI terminals)
        if backend.video:
            backend.video.close()
        iolayer.close_all()
        iolayer.close_devices()
            
def prepare_logging():
    """ Set logging format. """
    formatstr = '%(levelname)s: %(message)s'
    if config.options['debug']:
        logging.basicConfig(format=formatstr, level=logging.DEBUG)
    elif logfile:
        logging.basicConfig(format=formatstr, filename=os.path.join(plat.info_dir, logfile))
    else:
        logging.basicConfig(format=formatstr)
        
def prepare_console():
    """ Initialise backend and console. """
    # initialise video backend before console
    if not backend.init_video() or not console.init():
        backend.video.close()
        logging.error('Failed to initialise interface. Exiting.')
        raise error.Exit()
    if not backend.init_sound() or not sound.init_sound():
        logging.warning('Failed to initialise sound. Sound will be disabled.')
    # need to call explicitly to run after console.prepare(), 
    # because of circular imports
    import redirect
    redirect.prepare()    

def convert():
    """ Perform file format conversion. """
    # set conversion output 
    # first arg, if given, is mode; second arg, if given, is outfile
    outfile = ''
    conv = config.options['conv'].split(':')
    try:
        mode = conv.pop(0)
        outfile = conv.pop(0)
    except IndexError:
        pass    
    # keep uppercase first letter    
    mode = mode[0].upper() if mode else 'A'
    # load & save in different format
    if config.options['program']:
        program.load(oslayer.safe_open(config.options['program'], "L", "R"))
    elif plat.stdin:
        program.load(plat.stdin)      
    if outfile:
        program.save(oslayer.safe_open(outfile, "S", "W"), mode)
    elif plat.stdout:
        program.save(plat.stdout, mode)

def print_greeting():
    if (not config.options['run'] and
        not (config.options['program'] and not config.options['load']) and
        not config.options['exec']):
        debugstr = ' [DEBUG mode]' if config.options['debug'] else ''
        if plat.stdin_is_tty:
            console.write_line(greeting % (debugstr, var.total_mem))
    
def load_program():
    """ Load program from command line. """
    # --load or --run without argument loads from stdin (e.g. pipe)
    program_to_load = config.options['program']
    if program_to_load:
        program.load(oslayer.safe_open(program_to_load, "L", "R"))
    elif config.options['load'] or config.options['run'] and plat.stdin:
        program.load(plat.stdin)      
    
def run_commands():
    """ Run commands or program from command line. """
    command = config.options['exec']
    if (config.options['run'] or 
            (config.options['program'] and not config.options['load'])): 
        command = 'RUN'
    if command:    
        run.execute(command)
            
            
if __name__ == "__main__":
    main()
        
