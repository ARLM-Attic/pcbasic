#!/usr/bin/env python

#
# PC-BASIC 3.23 
#
# GW-BASIC (R) compatible interpreter 
# 
# (c) 2013, 2014 Rob Hagemans 
#
# This file is released under the GNU GPL version 3. 
# please see text file COPYING for licence terms.
#
# GW-BASIC is a trademark of Microsoft Corporation.

import sys
import os
from functools import partial

import plat

# OS-specific stdin/stdout selection
# no stdin/stdout access allowed on packaged apps
if plat.system in ('OSX', 'Windows'):
    stdin_is_tty, stdout_is_tty = True, True
    stdin, stdout = None, None
else:
    # Unix, Linux including Android
    import backend_ansi
    try:
        stdin_is_tty = sys.stdin.isatty()
        stdout_is_tty = sys.stdout.isatty()
    except AttributeError:
        stdin_is_tty, stdout_is_tty = True, True
        stdin, stdout = None, None
    stdin, stdout = sys.stdin, sys.stdout

# do we log to a file? 
logfile = False

import logging

import config
import run
import error
import expressions
import oslayer
import sound
import nosound
import nopenstick
import sound_beep
import console
import tokenise
import machine
import program
import unicodepage
import debug
import state
import backend
import backend_pygame
import iolayer
import var
import statements
import on_event

greeting = 'PC-BASIC 3.23%s\r(C) Copyright 2013, 2014 PC-BASIC authors. Type RUN "@:INFO" for more.\r%d Bytes free\rOk\xff'
debugstr = ''

def main():
    reset = False
    args = config.get_args()
    # DEBUG, PCjr and Tandy modes
    prepare_keywords(args)
    # other command-line settings
    prepare_constants(args)
    try:
        if args.resume or plat.system == 'Android':
            # resume from saved emulator state
            args.resume = state.load()
        # choose the video and sound backends
        prepare_console(args)
        # choose peripherals    
        iolayer.prepare_devices(args)
        if not args.resume:    
            # print greeting
            if not args.run and not args.cmd and not args.conv:
                if stdin_is_tty:
                    console.write_line(greeting % (debugstr, var.total_mem))
            # execute arguments
            if args.run or args.load or args.conv and (args.program or stdin):
                program.load(oslayer.safe_open(args.program, "L", "R") if args.program else stdin)
            if args.conv and (args.outfile or stdout):
                program.save(oslayer.safe_open(args.outfile, "S", "W") if args.outfile else stdout, args.conv_mode)
                raise error.Exit()
            if args.run:
                args.cmd = 'RUN'
            if args.cmd:    
                # start loop in execute mode
                run.execute(args.cmd)
        # start the interpreter loop
        # and get out, if we ran with -q
        run.loop(args.quit)
    except error.RunError as e:
        # errors during startup/conversion are handled here, then exit
        logging.error(error.get_message(e.err))
    except error.Exit:
        pass
    except error.Reset:
        reset = True
    except KeyboardInterrupt:
        if args.debug:
            raise
    finally:
        if reset:
            state.delete()
        else:   
            state.save()
        # fix the terminal on exit or crashes (inportant for ANSI terminals)
        console.close()
        iolayer.close_all()
        iolayer.close_devices()
            
def prepare_keywords(args):
    global debugstr
    if args.debug:
        debug.debug_mode = True
        tokenise.insert_debug_keyword()
        # set logging format
        logging.basicConfig(format='%(levelname)s: %(message)s', level=logging.DEBUG)
        debugstr = ' [DEBUG mode]'
    else:
        # set logging format
        if logfile:
            logging.basicConfig(format='%(levelname)s: %(message)s', filename = os.path.join(plat.basepath, 'info', 'PCBASIC.LOG'))
        else:
            logging.basicConfig(format='%(levelname)s: %(message)s')
    if args.pcjr_syntax and len(args.pcjr_syntax)>0:
        statements.pcjr_syntax = args.pcjr_syntax[0]
        expressions.pcjr_syntax = args.pcjr_syntax[0]
        sound.pcjr_sound = args.pcjr_syntax[0]
        tokenise.insert_noise_keyword()
        tokenise.insert_term_keyword() 
        if statements.pcjr_syntax == 'tandy':
            # tandy recognises 12 function keys
            on_event.num_fn_keys=12
            if not args.resume:
                # tandy has SOUND ON by default
                state.console_state.sound_on = True
    # set pcjr TERM program    
    if args.pcjr_term:
        statements.pcjr_term = args.pcjr_term[0]
        
def prepare_constants(args):
    # PEEK presets
    if args.peek != None:
        try:
            for a in args.peek:
                seg, addr, val = a.split(':')
                machine.peek_values[int(seg)*0x10 + int(addr)] = int(val)
        except (TypeError, ValueError):
            pass     
    # drive mounts           
    if args.mount != None:
        try:
            for a in args.mount:
                # last one specified sticks
                letter, path = a.split(':',1)
                oslayer.drives[letter.upper()] = os.path.realpath(path)
                oslayer.drive_cwd[letter.upper()] = ''
        except (TypeError, ValueError):
            pass                
    # implied RUN invocations
    if args.program and not args.load and not args.conv:
        args.run = True   
    if args.double:
        expressions.option_double = True    
    if (not args.strict_hidden_lines) or args.conv:
        program.max_list_line = 65535    
    if (not args.strict_protect) or args.conv:
        program.dont_protect = True    
    if args.codepage:
        state.console_state.codepage = args.codepage[0]
    if args.nobox:
        unicodepage.box_protect = False
    # rename exec argument for convenience
    try:
        args.cmd = getattr(args, 'exec') 
    except AttributeError:
        args.cmd = ''    
    if not args.cmd:
        args.cmd = ''   
    # set conversion output; first arg, if given, is mode; second arg, if given, is outfile
    args.conv_mode = 'A'
    args.outfile = None
    if args.conv:
        args.conv = args.conv.split(':')
        try:
            args.conv_mode = args.conv.pop(0)
            args.outfile = args.conv.pop(0)
        except IndexError:
            pass    
        args.conv = True    
    if args.conv_mode:
        args.conv_mode = args.conv_mode[0].upper()        
    if args.strict_newline:
        program.universal_newline = False
    else:
        program.universal_newline = True
    if args.windows_map_drives:
        oslayer.windows_map_drives()
    if args.video:
        console.video_capabilities = args.video[0]
        if args.video[0] == 'ega':
            args.composite = False
    if args.cga_low:
        console.cga_palette_0 = console.cga_palette_0_lo
        console.cga_palette_1 = console.cga_palette_1_lo
        console.cga_palette_5 = console.cga_palette_5_lo
        console.cga_palettes = [console.cga_palette_0, console.cga_palette_1]
    if args.max_files:
        iolayer.max_files = config.parse_int_option_silent(args.max_files)
    if args.max_reclen:
        iolayer.max_reclen = config.parse_int_option_silent(args.max_reclen)
        if iolayer.max_reclen < 1:
            iolayer.max_reclen = 1
        if iolayer.max_reclen > 32767:
            iolayer.max_reclen = 32767
    if args.serial_in_size:
        iolayer.serial_in_size = config.parse_int_option_silent(args.serial_in_size)
    if args.utf8:
        program.utf8_files = True
        
def prepare_console(args):
    # set codepage and font family
    state.console_state.codepage = unicodepage.load_codepage(state.console_state.codepage)
    # codepage needs to be loaded for dbcs to work correctly
    import backend_cli
    import novideo
    import redirect
    # set font family
    if args.font:
        console.font_families = args.font
    # set backends
    backend.penstick = nopenstick
    backend.sound = nosound
    if args.filter or args.conv or (not args.graphical and not args.ansi and (not stdin_is_tty or not stdout_is_tty)):
        # redirected input or output leads to dumbterm use
        backend.video = novideo
        backend.sound = nosound
    elif args.cli and stdout_is_tty:
        backend.video = backend_cli
        backend.sound = sound_beep
    elif args.ansi and stdout_is_tty:
        backend.video = backend_ansi
        backend.sound = sound_beep
    else:   
        backend.video = backend_pygame   
        backend.penstick = backend_pygame
        backend.sound = backend_pygame
        backend_pygame.prepare(args)
    # initialise backends 
    if args.run:
        state.console_state.keys_visible = False
    if not console.init():
        logging.warning('Failed to initialise interface. Falling back to command-line interface.')
        backend.video = backend_cli
        backend.sound = sound_beep        
        if not backend.video or not console.init():
            logging.warning('Failed to initialise interface. Falling back to filter interface.')
            backend.video = novideo
            backend.sound = nosound
    # sound fallback        
    if args.nosound:
        backend.sound = nosound
    if not sound.init_sound():
        logging.warning('Failed to initialise sound. Sound will be disabled.')
        backend.sound = nosound
    # gwbasic-style redirected output is split between graphical screen and redirected file    
    if args.output:
        redirect.set_output(oslayer.safe_open(args.output[0], "S", "W"))
    if args.input:
        redirect.set_input(oslayer.safe_open(args.input[0], "L", "R"))
    if args.capture_caps:
        console.ignore_caps = False
    if args.keys:
        for u in args.keys.decode('string_escape').decode('utf-8'):
            c = u.encode('utf-8')
            try:
                state.console_state.keybuf += unicodepage.from_utf8(c)
            except KeyError:
                state.console_state.keybuf += c
                

if __name__ == "__main__":
    main()
        
