<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" type="text/css" href="docstyle.css">
<title></title>
</head>
<body>


<h1>PC-BASIC language reference</h1>

types
variables
arrays
literals

events
error trapping

- list of devices
- list of screen modes
- colour codes ?
- keyword list
- error codes

** keyword reference


Technical documentation
- MBF
- random numbers
- memory map

<h2>Keywords</h2>

<h3>
<code>ABS</code> function
</h3>
<pre>
<em>y</em> = ABS(<em>x</em>)
</pre>
<p>Returns the absolute value of <code><em>x</em></code>. 
<h4>Parameters</h4>
<ul><li>
<code><em>x</em></code> is an expression with a numeric value.</p>
</li></ul>
<h4>Errors</h4>
<ul>
<li>
<code><em>x</em></code> has a string value: <code>Type mismatch</code>.
</li>
</ul>

<h3>
<code>ASC</code> function
</h3>
<pre>
<em>val</em> = ASC(<em>char</em>)
</pre>
<p>Returns the ASCII code for the first character of <code><em>char</em></code>. </p>
<h4>Parameters</h4>
<ul><li>
<code><em>char</em></code> is an expression with 
a string value.
</li></ul>
<h4>Errors</h4>
<ul>
<li>
<code><em>char</em></code> has a numeric value: <code>Type mismatch</code>.
</li><li>
<code><em>char</em></code> equals <code>""</code>: <code>Illegal function call</code>.
</li>
</ul>


<h3>
<code>ATN</code> function
</h3>
<pre>
<em>y</em> = ATN(<em>x</em>)</code>
</pre>
<p>Returns the inverse tangent of <code><em>x</em></code>. 

<h4>Parameters</h4>
<ul><li>
<code><em>x</em></code> is a numeric expression that gives 
the angle in radians. 
</li></ul>
<h4>Notes</h4>
<ul>
<li>
Unless PC-BASIC is run with the <code>double</code> option, this function 
returns a single-precision value.</li>
<li>
<code>ATN(x)</code> differs in the least significant digit from GW-BASIC.
</li>
</ul>
<h4>Errors</h4>
<ul>
<li>
<code><em>x</em></code> has a string value: <code>Type mismatch</code>.
</li>
</ul>

<h3>
<code>
AUTO</code> statement
</h3>
<pre>
AUTO [ { <em>line_number</em> | . } ] [, [<em>increment</em>]] 
</pre>
<p>Start automatic line numbering. Line numbers 
are automatically generated when <code><b>Enter</b></code> is pressed.
If a program line exists at a generated line number, a <code>*</code> is shown after the 
line number. To avoid overwriting this line, leave it empty and press <code><b>Enter</b></code>.
To stop automatic line numbering, press <code><b>Ctrl</b></code>+<code><b>Break</b></code> or <code><b>Ctrl</b></code>+<code><b>C</b></code>. The line being edited at 
that point is not saved. BASIC will return to command mode, even if <code>AUTO</code> was 
run from a program line.
<h4>Parameters</h4>
<ul><li>
Line numbering starts at <code><em>line_number</em></code>, if specified. If <code>.</code> is specified, line 
numbering starts at the last program line that was stored. Otherwise, line
numbering starts at <code>10</code>.
</li><li> 
Each next line number is incremented by <code><em>increment</em></code>, if specified. If a comma 
is used without specifying an increment, the last increment specified in an 
<code>AUTO</code> command is used. If not, <code><em>increment</em></code> defaults to <code>10</code>.
</li></ul>
</p>
<h4>Errors</h4>
<ul>
<li>
<code><em>line_number</em></code> is not an unsigned-integer value in <code>[0&mdash;65529]</code>:
   <code>Syntax error</code>.
</li><li>
When automatic line numbering is enabled and <code><b>Enter</b></code> is pressed on an empty line with number larger than 
   <code>65519</code>: <code>Undefined line number</code>.
</li></ul>

<h3><code>BEEP</code> statement</h3>
<pre>
BEEP
</pre>
<p>Beep the speaker at 800Hz for 0.25s.</p>
<h4>Errors</h4>
<ul>
<li>
If a <code>Syntax error</code> is raised, the beep is still produced.
</li></ul>

<h3><code>BEEP</code> statement (switch)</h3>
<pre>
BEEP { ON | OFF }
</pre>
<p>This statement has no effect.</p>
<h4>Notes</h4>
<ul><li>
Only legal with the <code>syntax={pcjr|tandy}</code> option.
</li><li>
On PCjr and Tandy computers, <code>BEEP OFF</code> would turn off the internal speaker. 
    On PC-BASIC, both the internal and the external speaker are emulated through
    the same sound system.
</li></ul>

<h3><code>BLOAD</code> statement</h3>
<pre>
BLOAD <em>filename</em> [ ,<em>offset</em> ]
</pre>
<p>Loads an image file into memory. </p>
<h4>Parameters</h4>
<ul>
<li>
<code><em>filename</em></code> is a string expression indicating the 
file to read from.</em>
</li><li>
<code><em>offset</em></code> is a numeric expression in the range <code>[-32768&mdash;65536]</code>.
It indicates an offset in the current <code>DEF SEG</code> segment where the file is to be
stored. If not specified, the offset stored in the <code>BSAVE</code> file will be used. If
negative, its two's complement will be used.
</li>
</ul>
<h4>Errors</h4>
<ul><li><code><em>filename</em></code> is not in <code>BSAVE</code> format: <code>Bad file mode</code>.</li>
<li>
<code><em>filename</em></code> has a numeric value: <code>Type mismatch</code>.
</li><li>
<code><em>offset</em></code> is not in the range <code>[-32768&mdash;65536]</code>: <code>Overflow</code>.
</li></ul>


<h3><code>BSAVE</code> statement</h3>
<pre>
BSAVE <em>filename</em>, <em>offset</em>, <em>length</em>
</pre>
<p>Saves a region of memory to an image file.</p>
<h4>Parameters</h4>
<ul>
<li>
<code><em>filename</em></code> is a string expression indicating the 
file to read from.</em>
</li><li>
<code><em>offset</em></code> is a numeric expression in the range <code>[-32768&mdash;65536]</code> indicating
the offset into the current <code>DEF SEG</code> segment from where to start reading.
</li><li>
<code><em>length</em></code> is a numeric expression in the range <code>[-32768&mdash;65536]</code> indicating
the number of bytes to read. 
</li><li>
If <code><em>offset</em></code> or <code><em>length</em></code> are negative, their two's
complement will be used.</li>
</ul>
<h4>Errors</h4>
<ul><li>
<code><em>filename</em></code> has a numeric value: <code>Type mismatch</code>.
</li><li>
<code><em>offset</em></code> is not in the range <code>[-32768&mdash;65536]</code>: <code>Overflow</code>.
</li><li>
<code><em>length</em></code> is not in the range <code>[-32768&mdash;65536]</code>: <code>Overflow</code>.
</li></ul>

<h3><code>CALL</code> statement</h3>
<pre>
CALL <em>address_var</em> [ ( <em>p0</em> [ ,<em>p1</em> [ , ... ] ) ]
</pre>
<p>Does nothing.</p>
<h4>Notes</h4>
<ul><li>
In GW-BASIC, <code>CALL</code> executes a machine language subroutine. 
</li><li>
This statement is not implemented in PC-BASIC.  
</li></ul>
<h4>Parameters</h4>
<ul><li>
<code><em>address_var</em></code> is a numeric variable name. 
</li><li>
<code><em>p0</em>, <em>p1</em>, ...</code> are variable names.
</li></ul>
<h4>Errors</h4>
<ul><li>
<code><em>address_var</em></code> is a string variable name: <code>Type mismatch</code>.
</li><li>
<code><em>address_var</em></code> is a literal: <code>Syntax error</code>.
</li></ul>


<h3><code>CALLS</code> statement</h3>
<pre>
CALLS <em>address_var</em> [ ( <em>p0</em> [ ,<em>p1</em> [ , ... ] ) ]
</pre>
<p>Does nothing.</p>
<h4>Notes</h4>
<ul><li>
In GW-BASIC, <code>CALLS</code> executes a FORTRAN subroutine. 
</li><li>
This statement is not implemented in PC-BASIC.  
</li></ul>
<h4>Parameters</h4>
<ul><li>
<code><em>address_var</em></code> is a numeric variable name. 
</li><li>
<code><em>p0</em>, <em>p1</em>, ...</code> are variable names.
</li></ul>
<h4>Errors</h4>
<ul><li>
<code><em>address_var</em></code> is a string variable name: <code>Type mismatch</code>.
</li><li>
<code><em>address_var</em></code> is a literal: <code>Syntax error</code>.
</li></ul>


<h3><code>CDBL</code> function</h3>
<pre>
<em>y</em> = CDBL(<em>x</em>)
</pre>
<p>
Converts the numeric expression <code><em>x</em></code> to a double-precision value.
</p>
<h4>Errors</h4>
<ul>
<li>
<code><em>x</em></code> has a string value: <code>Type mismatch</code>.
</li>
</ul>

<h3><code>CHAIN</code> statement</h3>
<pre>
CHAIN [MERGE] <em>program</em> [ ,[<em>line_number_expr</em>] [ ,ALL ] [ ,DELETE <em>range</em> [ ,<em>ign</em> ] ] ]
</pre>
<p>Loads <code><em>program</em></code> into memory and runs it, optionally transferring variables.</p>
<ul>
<li>If <code>ALL</code> is specified, all variables are transferred. If not, the variables 
specified in a <code>COMMON</code> statement are transferred. </li>
<li>If <code>MERGE</code> is specified, <code><em>program</em></code> is merged into the existing program. To be 
able to use this, <code><em>program</em></code> must be saved as ASCII.
</li><li>
If <code>DELETE</code> is specified, the <code><em>range</em></code> of line numbers is deleted from the 
existing code before the merge. This is pointless without <code>MERGE</code>.
</li>
</ul>
<h4>Parameters</h4>
<ul><li>
<code><em>line_number_expr</em></code> is a numeric expression. It 
will be interpreted as a line number in the new program and execution will 
start from this line number. If <code><em>line_number_expr</em></code> is negative, it will be 
interpreted as its two's-complement.
</li><li>
<code><em>range</em></code> is a line number range of which the closing line number is
specified and exists before the merge.
</li><li>
<code><em>ign</em></code> is optional and ignored. 
</li></ul>
</p>
<h4>Notes</h4>
<ul><li>
<code>CHAIN</code> preserves the <code>OPTION BASE</code> setting.
</li><li>
<code>COMMON</code> variables remain <code>COMMON</code> for the next CHAIN.
</li><li>
Only if <code>ALL</code> is specified, <code>DEF FN</code> definitions are preserved.
</li><li>
Only if <code>MERGE</code> is specified, <code>DEFINT</code>, <code>DEFSTR</code>, <code>DEFSNG</code>, <code>DEFDBL</code> definitions 
    are preserved.
</li><li>
If specified, <code>ALL</code> must precede <code>DELETE</code>; if unspecified, no comma must
    be put in its place and only two commas should precede <code>DELETE</code>.
</li></ul>
<h4>Errors</h4>
<ul>
<li>
<code>MERGE</code> is specified and <code><em>program</em></code> was not saved in ASCII mode: 
<code>Bad file mode</code>.
</li><li>
A line number in <code><em>range</em></code> is greater than 65529: <code>Syntax error</code>.
</li>
<li>
If a <code>Syntax error</code> is raised by <code>CHAIN</code>, no lines are deleted and the new
program is not loaded.
</li>
<li>The closing line number in <code><em>range</em></code> does not exist: <code>Illegal function call</code></li>
<li>
If <code><em>line_number_expr</em></code> does not evaluate to an existing line number in the
new program, <code>Illegal function call</code> is raised but the load or merge is 
being performed.
</li></ul>


<h3><code>CHDIR</code> statement</h3>
<pre>
CHDIR <em>pathname</em>
</pre>
<p>Change the working directory to <code><em>pathname</em></code>.</p>
<h4>Parameters</h4>
<ul><li>
 <code><em>pathname</em></code> is a string 
expression which can be absolute or relative to the current path. 
</li></ul>
<h4>Notes</h4>
<ul><li>
<code><em>pathname</em></code>
must be specified with MS-DOS path separators <code>\</code>. 
</li><li>
<code>CHDIR</code> first looks for the
exact, case-sensitive (on Unix) path <code><em>pathname</em></code>; if this does not exist then
an uppercase version truncated to 8.3 is attempted. The search will match the
first 8.3 filename (in lexicographic order) whose uppercase version equals the
requested name. 
</li>
</ul>
<h4>Errors</h4>
<ul><li>
No matching path is found: <code>Path not found</code>.
</li><li>
<code><em>pathname</em></code> has a numeric value: <code>Type mismatch</code>.
</li><li>
<code><em>pathname</em></code> is empty: <code>Bad file name</code>.
</li></ul>

<h3><code>CHR$</code> function</h3>
<pre><em>char</em> = CHR$(<em>x</em>)
</pre>
<p>Returns the character with ASCII code <code><em>x</em></code>. 
</p>
<h4>Parameters</h4>
<ul><li>
<code><em>x</em></code> is a numeric expression in the range <code>[0&mdash;255]</code>.
</li></ul>
<h4>Errors</h4>
<ul><li>
<code><em>x</em></code> has a string value: <code>Type mismatch</code>.
</li><li>
<code><em>x</em></code> is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
</li><li>
<code><em>x</em></code> is not in <code>[0&mdash;255]</code>: <code>Illegal function call</code>.
</li></ul>


<h3><code>CINT</code> function</h3>
<pre><em>y</em> = CINT(<em>x</em>)
</pre>
<p>Converts the numeric expression <code><em>x</em></code> to a signed integer.</p>
<h4>Errors</h4>
<ul><li>
<code><em>x</em></code> has a string value: <code>Type mismatch</code>.
</li><li>
<code><em>x</em></code> is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
</li></ul>


<h3><code>CIRCLE</code> statement</h3>
<pre>
CIRCLE [STEP] (<em>x</em>, <em>y</em>), <em>radius</em> [, [<em>colour</em>] [, [<em>start</em>] [, [<em>end</em>] [, <em>aspect</em>] ] ]
</pre>
<p>Draw an ellipse or ellipse sector. </p>
<h4>Parameters</h4>
<ul><li>
The midpoint of the ellipse is at <code><em>x</em></code>,<code><em>y</em></code>.
If <code>STEP</code> is specified, the midpoint is <code><em>x</em></code>,<code><em>y</em></code> away from the current position.
</li><li>
<code><em>radius</em></code> is the radius, in pixels, along the long axis.
</li><li>
<code><em>colour</em></code> is the colour attribute.
</li><li>
If <code><em>start</em></code> and <code><em>end</em></code> are specified, a sector of the ellipse is drawn from 
<code><em>start</em></code> radians to <code><em>end</em></code> radians, with zero radians the intersection with the 
right-hand x axis. If a negative value is specified, the arc sector is 
connected by a line to the midpoint.
</li><li>
<code><em>aspect</em></code> specifies the ratio between the y radius and the x radius. If it is
not specified, the standard value for the <code>SCREEN</code> mode is used (see there), so
as to make the ellipse appear like a circle on the original hardware. 
</li></ul>
<h4>Notes</h4>
<ul><li>
For <code><em>aspect</em> <> 1</code>, the midpoint algorithm used does not pixel-perfectly 
   reproduce GW-BASIC's ellipses.
</li></ul>
<h4>Errors</h4>
<ul><li>
  The statement is executed in text mode: <code>Illegal function call</code>.
</li><li>
  <code><em>start</em></code> or <code><em>end</em></code> is not in <code>[0&mdash;2&pi;]</code>: <code>Illegal function call</code>.
</li><li>
  The statement ends with a comma: <code>Missing operand</code>.
</li></ul>


<h3><code>CLEAR</code> statement</h3>
<pre>CLEAR [<em>expr</em>] [, [<em>mem_limit</em>] [, <em>stack_size</em>] ]
</pre>
<p>Clears all variables, arrays,<code>DEF FN</code> user functions, <code>DEF<em>type</em></code> type definitions,
and <code>COMMON</code> declarations. Closes all files.  
Turns off all sound. Resets <code>PLAY</code> state and sets music to foreground.
Clears all <code>ON ERROR</code> traps. Resets <code>ERR</code> and <code>ERL</code> to zero. Disables all events. 
Turns <code>PEN</code> and <code>STRIG</code> off. Resets the random number generator. 
Clears the loop stack. Resets the <code>DRAW</code> state and the current graphics position.
</p>
<h4>Parameters</h4>
<ul><li>
<code><em>mem_limit</em></code> specifies the upper limit of usable memory. Default is previous
memory size. Default memory size is 65534.
</li><li>
<code><em>stack_size</em></code> specifies the amount of memory available to the BASIC stack. 
Default is previous stack size. Default stack size is 512.
</li></ul>
<h4>Notes</h4>
<ul><li>
  The purpose of <em>expr</em> is unknown.
</li><li>
  If called inside a <code>FOR</code>&mdash;<code>NEXT</code> or <code>WHILE</code>&mdash;<code>WEND</code> loop, an error will be raised at 
   the iteration keyword as the loop stacks are cleared.
</li></ul>
<h4>Errors</h4>
<ul><li>
Any of the arguments has a string value: <code>Type mismatch</code>.
</li><li>
<code><em>mem_limit</em></code>, <code><em>stack_size</em></code> are not in <code>[-32768&mdash;65535]</code>: <code>Overflow</code>.
</li><li>
<code><em>mem_limit</em></code> or <code><em>stack_size</em></code> equal <code>0</code>: <code>Illegal function call</code>.
</li><li>
<code><em>mem_limit</em></code> equals <code>-1</code> or <code>65535</code>: <code>Out of memory</code>.
</li><li>
<code><em>mem_limit</em></code> or <code><em>expr</em></code> are too low: <code>Out of memory</code>.
</li><li>
<code><em>expr</em></code> is not  in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
</li><li>
<code><em>expr</em></code> is negative: <code>Illegal function call</code>.
</li></ul>

<h3><code>CLOSE</code> statement</h3>
<pre>CLOSE [[#] <em>file_1</em> [, [#] <em>file_2</em> [, ...] ]</pre>
<p>Closes files. If no file numbers are specified, all open files are closed.
The hash (#) is optional and has no effect.</p>
<h4>Parameters</h4>
<ul><li>
<code><em>file_1</em>, <em>file_2</em>, ...</code> are numeric expressions yielding 
file numbers. 
</li></ul>
<h4>Notes</h4>
<ul><li>
No error is raised if the specified file numbers were not open.
</li></ul>
<h4>Errors</h4>
<ul><li>
<code><em>file_1</em>, <em>file_2</em>, ...</code> are not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
</li><li>
<code><em>file_1</em>, <em>file_2</em>, ...</code> are not in <code>[0&mdash;255]</code>: <code>Illegal function call</code>.
</li><li>
<code><em>file_1</em>, <em>file_2</em>, ...</code> have a string value: <code>Type mismatch</code>.
</li><li>
The statement ends in a comma, <code>Missing operand</code> .
</li><li>
 If an error occurs, only the files before the erratic value are closed.
</li></ul>


<h3><code>CLS</code> statement</h3>
<pre>CLS [<em>x</em>][,]</pre>
<p>Clears the screen or part of it. 
If <code><em>x</em></code> is not specified, in SCREEN 0 the text view region is cleared;
in other screens, the graphics view region is cleared.
The comma is optional and has no effect.</p>
<h4>Parameters</h4>
<p><code><em>x</em></code> is a numeric valued expression that determines what is cleared:</p>
<ul><li>
  If <code><em>x</em> = 0</code>, the whole screen is cleared.
</li><li>
  If <code><em>x</em> = 1</code>, the graphics view region is cleared.
</li><li>
  If <code><em>x</em> = 2</code>, the text view region is cleared.
</li></ul>
<h4>Errors</h4>
<ul><li>
<code><em>x</em></code> is has a string value: <code>Type mismatch</code>.
</li><li>
<code><em>x</em></code> is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code> .
</li><li>
<code><em>x</em></code> is not in <code>[0, 1, 2]</code>: <code>Illegal function call</code>.
</li><li>
No comma is specified but more text follows: <code>Illegal function call</code>.
</li><li>
A comma is specified followed by more: <code>Syntax error</code>.
</li><li>
If an error occurs, the screen is not cleared.
</li></ul>

<h3><code>COLOR</code> statement (text mode)</h3>
<pre>COLOR [<em>foreground</em>] [, [<em>background</em>] [, <em>border</em>] ] </pre>
<p>Changes the current foreground and background attributes.
All new characters printed will take the newly set attributes. Existing
characters on the screen are not affected.</p>
<h4>Parameters</h4>
<ul><li>
<code><em>foreground</em></code> is a numeric expression in <code>[0&mdash;31]</code>.
    This specifies the new foreground attribute. Attributes <code>16&mdash;31</code> are 
    blinking versions of attributes <code>0&mdash;15</code>.
</li><li>
<code><em>background</em></code> is a numeric expression in <code>[0&mdash;15]</code>.
    This specifies the new background attribute. It is taken <code>MOD 8</code>: Values 
    <code>8&mdash;15</code> produce the same colour as <code>0&mdash;7</code>.
</li><li>
<code><em>border</em></code> is a numeric expression in <code>[0&mdash;15]</code> specifying the border attribute.
</li></ul>
<h4>Notes</h4>
<ul><li>
   The syntax and effect of this command is different in different <code>SCREEN</code>
    modes. See below for other <code>SCREEN</code>s.
</li></ul>
<h4>Errors</h4>
<ul><li>
Any of the parameters has a string value: <code>Type mismatch</code>.
</li><li>
Any of the parameters is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
</li><li>
<code><em>foreground</em></code> is not in <code>[0&mdash;31]</code>, <code><em>background</em></code> is not in 
    <code>[0&mdash;15]</code> or <code><em>border</em></code> is not in <code>[0&mdash;15]</code>: <code>Illegal function call</code>.
</li><li>
Statement is used in <code>SCREEN 2</code>: <code>Illegal function call</code>. 
</li></ul>
    

<h3><code>COLOR</code> statement (<code>SCREEN 1</code>)</h3>
<pre>COLOR [<em>palette_0</em>] [, <em>palette</em> [, <em>override</em>] ]</pre>
<p>Assigns new colours to the palette of attributes. </p>
<ul><li>
<code><em>palette_0</em></code> is a numeric expression  in <code>[0&mdash;255]</code>.
    This sets the palette colour associated with attribute 0; by default, the
    background has this attribute. All pixels with this attribute will 
    change colour. The palette colour value is taken from the VGA 64-colour
    set. <code><em>palette_0</em></code> is taken <code>MOD 64</code>.  
</li><li>
<code><em>palette</em></code> is a numeric expression in <code>[0&mdash;255]</code> that specifies the palette:
    <ul><li>
    <code><em>palette</em></code> odd sets the standard CGA palette (cyan, magenta, grey).
    </li><li>
    <code><em>palette</em></code> even sets the alternative palette (green, red, brown).
    </li></ul>
    All pixels with attributes 1,2,3 will change colour to the new palette.
</li><li>
<code><em>override</em></code> is a numeric expression in <code>[0&mdash;255]</code>.
    If <code><em>override</em></code> is specified, palette is set as above but using <code><em>override</em></code>
    instead of <code><em>palette</em></code>. <code><em>palette</em></code> is then ignored.
</li></ul>
<h4>Errors</h4>
<ul><li>
Any of the parameters has a string value: <code>Type mismatch</code>.
</li><li>
Any of the parameters is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
</li><li>
Any of the parameters is not in <code>[0&mdash;255]</code>: <code>Illegal function call</code>.
</li></ul>


<h3><code>COLOR</code> statement (<code>SCREEN 3&mdash;9</code>)</h3>
<pre>COLOR [<em>foreground</em>] [, <em>palette_0</em> [, <em>dummy</em>] ]</pre>
<p>Changes the current foreground attribute and the colour for attribute 0.</p>
<h4>Parameters</h4>
<ul><li>
<code><em>foreground</em></code> is a numeric expression in <code>[0&mdash;15]</code> 
    This sets the new foreground attribute. This applies only to new characters
    printed or pixels plotted.
</li><li>
<code><em>palette_0</em></code> is a numeric expression in <code>[0&mdash;15]</code> 
    This sets the colour associated with attribute 0; by default, the
    background has this attribute. All pixels with this attribute will 
    change colour. 
In <code>SCREEN 7</code> and <code>8</code>, the <code><em>palette_0</em></code> colour is taken from the first 8 of 
the 16-colour EGA set. <code><em>palette_0</em></code> is taken <code>MOD 8</code>.
IN <code>SCREEN 9</code>, the colour value is taken from the 64-colour VGA set.
</li><li>
<code><em>dummy</em></code> is a numeric expression with a value in <code>[0&mdash;255]</code> 
    The value of <code><em>dummy</em></code> is ignored.
</li></ul>
<h4>Errors</h4>
<ul><li>
Any of the parameters has a string value: <code>Type mismatch</code>.
</li><li>
Any of the parameters is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
</li><li>
<code><em>foreground</em></code> is not in <code>[1&mdash;15]</code>; <code><em>background</em></code> is not in <code>[0&mdash;15]</code>; or 
    <code><em>dummy</em></code> is not in <code>[0&mdash;255]</code>: <code>Illegal function call</code>.
</li></ul>


<h3><code>COM</code> statement</h3>
<pre>COM(<em>port</em>) { ON | OFF | STOP }</pre>
<ul>
<li><code>ON</code>: enables <code>ON COM(<em>port</em>)</code> event trapping of the emulated serial port. 
</li><li>
<code>OFF</code>: disables trapping.
</li><li>
<code>STOP</code>: halts trapping until <code>COM(<em>port</em>) ON</code> is used. Events that occur 
while trapping is halted will trigger immediately when trapping is re-enabled.</p>
</li></ul>
<h4>Parameters</h4>
<ul><li><code><em>port</em></code> is a numeric expression with a value of <code>1</code> or <code>2</code>. This specifies which
serial port (<code>COM1:</code> or <code>COM2:</code>) is trapped.
</li></ul>


<h3><code>COMMON</code> statement</h3>
<pre>COMMON</code> [ [<em>var_0</em>] [, [<em>var_1</em>] [, [...] ] ] ]</pre>
<p>Specifies variables to be passed as common variables to the program called 
with <code>CHAIN</code>. 
The statement may end with one or more commas. </p>
<h4>Parameters</h4>
<ul><li>
<code><em>var_0</em>, <em>var_1</em>, ...</code> are names of variables or arrays. Array names
must be followed by round or square brackets. Brackets may also be mixed <code>a(]</code> <code>b[)</code>.
</li></ul>


<h3><code>CONT</code> statement</h3>
<pre>CONT [ <em>anything</em> ]</pre>
<p>Resumes execution of a program that has been halted by <code>STOP</code>, <code>END</code>, <code><b>Ctrl</b></code>+<code><b>C</b></code>, or  <code><b>Ctrl</b></code>+<code><b>Break</b></code>. </p>
<h4>Notes</h4>
<ul><li>
Anything after the <code>CONT</code> keyword is ignored.
</li><li>
   If a break is encountered in <code>GOSUB</code> routine called from a continuing
    direct line (e.g. <code>GOSUB 100:PRINT A$</code>), <code>CONT</code> will overwrite the running
    direct line. As the subroutine <code>RETURN</code>s to the position after the <code>GOSUB</code> in
    the old direct line, strange things may happen if commands are given after
    <code>CONT</code>. In GW-BASIC, this can lead to strange errors in non-existing
    program lines as the parser executes bytes that are not part of a program 
    line. In PC-BASIC, if the new direct line is shorter, execution stops
    after <code>RETURN</code>; but if the direct line is extended beyond the old return
    position, the parser tries to resume at that return position, with strange
    effects.
</li></ul>
<h4>Errors</h4>
<ul><li>
No program is loaded, a program has not been run, after a program line 
    has been modified or after <code>CLEAR</code>: <code>Can't continue</code>.
</li><li>
The break occurred in a direct line: <code>Can't continue</code>    
</li></ul>


<h3><code>COS</code> function</h3>
<pre><em>cosine</em> = COS(<em>angle</em>)</pre>
<p>Returns the cosine of <code><em>angle</em></code>. 
Unless PC-BASIC is run with the <code>--double</code> option, this function returns a single-precision
value.</p>
<h4>Parameters</h4>
<ul><li>
<code><em>angle</em></code> is a numeric expression that 
gives the angle in radians. 
</li></ul>
<h4>Notes</h4>
<ul><li>
   The return value usually differs from the value returned by GW-BASIC in the least significant figure.
</li></ul>
<h4>Errors</h4>
<ul><li>
<code><em>angle</em></code> has a string value: <code>Type mismatch</code>.
</li></ul>
     

<h3><code>CSNG</code> function</h3>
<pre><em>y</em> = CSNG(<em>x</em>)</pre>
<p>
Converts the numeric expression <code><em>x</em></code> to a single-precision value.</p>
<h4>Errors</h4>
<ul><li>
<code><em>x</em></code> has a string value: <code>Type mismatch</code>.
</li></ul>

<h3><code>CSRLIN</code> function</h3>
<pre><em>y</em> = CSRLIN </pre>
<p>Returns the screen row of the cursor on the active page. 
The return value is in the range <code>[1&mdash;25]</code>.</p>
<h4>Notes</h4>
<ul><li>
This function has no brackets.
</li></ul>

<h3><code>CVI</code> function</h3>
<pre><em>y</em> = CVI(<em>s</em>)</pre>
<p>Converts a two-byte string to a signed integer.</p>
</p>
<h4>Parameters</h4>
<ul><li>
<code><em>s</em></code> is a string expression that represents an integer using
little-endian two's complement encoding. Only the first two bytes are used.
</li></ul>
<h4>Errors</h4>
<ul><li>
<code><em>s</em></code> has a numeric value: <code>Type mismatch</code>.
</li></ul>

<h3><code>CVS</code> function</h3>
<pre><em>y</em> = CVS(<em>s</em>)</pre>
<p>Converts a four-byte string to a single-precision floating-point number.</p>
<h4>Parameters</h4>
<ul><li>
<code><em>s</em></code> is a string expression that represents a single-precision
number in Microsoft Binary Format. Only the first four bytes are used.
</li></ul>
<h4>Errors</h4>
<ul><li>
<code><em>s</em></code> has a numeric value: <code>Type mismatch</code>.
</li></ul>

<h3><code>CVD</code> function</h3>
<pre><em>y</em> = CVD(<em>s</em>)</pre>
<p>Converts an eight-byte string to a double-precision floating-point number.</p>
<h4>Parameters</h4>
<ul><li>
<code><em>s</em></code> is a string expression  that represents a double-precision
number in Microsoft Binary Format. Only the first eight bytes are used.
</li></ul>
<h4>Errors</h4>
<ul><li>
<code><em>s</em></code> has a numeric value: <code>Type mismatch</code>.
</li></ul>
 

<h3><code>DATA</code> statement</h3>
<pre>DATA [ [<em>const_0</em>] [, [<em>const_1</em>] [, ... ]</pre>
<p>Specifies data that can be read by a READ statement.</p>
<h4>Parameters</h4>
<ul><li>
<code><em>const_0</em>, <em>const_1</em>, ...</code>
are string and number literals or may be empty. String literals can be given
with or without quotation marks. If quotation marks are omitted, leading and
trailing whitespace is ignored and commas or colons will terminate the data
statement.
</li></ul>
<h4>Errors</h4>
<ul><li>
If the type of the literal does not match that of the corresponding <code>READ</code>
statement, a <code>Syntax error</code> occurs on the <code>DATA</code> statement.
</li></ul>
    
<h3><code>DATE$</code> function</h3>
<pre><em>s</em> = DATE$</pre>
<p>Returns the system date as a string in the format <code>"mm-dd-yyyy"</code>.</p>
<h4>Notes</h4>
<ul><li>
This function has no brackets.
</li></ul>

<h3><code>DATE$</code> statement</h3>
<pre>DATE$ = <em>date</em></pre>
<p>Sets the system date. <code><em>date</em></code> is a string expression that represents a 
date in one of the formats: <code>"mm-dd-yyyy"</code>, <code>"mm/dd/yyyy"</code>, <code>"mm-dd-yy"</code>, <code>"mm/dd/yy"</code>.</p>
<p>Of these, </p>
<ul><li>
<code>mm</code> must be in <code>[01&mdash;12]</code>.
</li><li>
<code>dd</code> must be in <code>[01&mdash;31]</code>. 
</li><li>
<code>yyyy</code> must be in <code>[1980&mdash;2099]</code>. 
</li><li>
<code>yy</code> must be in one of the ranges:
    <ul><li>
    <code>[00&mdash;77]</code>, interpreted as <code>2000&mdash;2077</code>; or
    </li><li>
    <code>[80&mdash;99]</code>, interpreted as <code>1980&mdash;1999</code>.
    </li></ul>
</li></ul>
<h4>Notes</h4>
<ul><li>
   The system date is not actually changed; rather, PC-BASIC remembers the 
    offset from the true system date. This avoids requiring user permission
    to change the system time.
</li><li>
   GW-BASIC appears to accept invalid dates such as <code>"02-31-2000"</code>. PC-BASIC
    raises <code>Illegal function call</code> for these.
</li></ul>
<h4>Errors</h4>
<ul><li>
<code><em>date</em></code> has a numeric value: <code>Type mismatch</code>.
</li><li>
<code><em>date</em></code> is not in the format specified above:
    <code>Illegal function call</code>.
</li></ul>

<h3><code>DEF FN</code> statement</h3>
<pre>DEF FN[ ]<em>name</em>[( <em>arg_0</em> [, <em>arg_1</em> [, ...] )] = <em>expression</em></pre>
<p>Defines a function called <code>FN<em>name</em></code> (or <code>FN<em> name</em></code>: spaces between <code>FN</code> and <code><em>name</em></code> are optional).
On calling <code>FN<em>name</em>( ... )</code>, <code><em>expression</em></code> is 
evaluated with the supplied parameters substituted. The result of the 
evaluation is the return value of <code>FN<em>name</em></code>.
</p>
<h4>Notes</h4>
<ul><li>
This statement may only be used on a program line.
</ul></li>
<h4>Parameters</h4>
<ul><li>
<code><em>name</em></code> must be a legal variable name.
</li><li>
<code><em>arg_0</em>, <em>arg_1</em>, ...</code> must be legal variable names. These are the parameters of the
function. Variables of the same name may or may not exist in the program; their value is not affected or used by the defined function.
</li><li>
<code><em>expression</em></code> must be a legal PC-BASIC expression that may use the
parameters <code><em>arg_0</em>, <em>arg_1</em>, ...</code>. 
</li></ul>
<h4>Errors</h4>
<ul><li>
The statement is executed directly instead of in a program line: <code>Illegal direct</code>.
</li></ul>


<h3><code>DEFINT</code> statement</h3>
<pre>DEFINT <em>letters</em></pre>
<p>Sets the default type for variables starting with <code><em>letters</em></code> to integer (<code>%</code>). 
This is the type that is assumed if no type character is specified. <code><em>letters</em></code> 
are letters of the alphabet separated by commas or ranges specified with a 
dash: for example, <code>DEFINT A,B,C-Z</code>.</p>


<h3><code>DEFDBL</code> statement</h3>
<pre>DEFDBL <em>letters</em></pre>
<p>Sets the default type for variables starting with <code><em>letters</em></code> to double (<code>#</code>). 
This is the type that is assumed if no type character is specified. <code><em>letters</em></code> 
are letters of the alphabet separated by commas or ranges specified with a 
dash: for example, <code>DEFDBL A,B,C-Z</code>.</p>


<h3><code>DEFSNG</code> statement</h3>
<pre>DEFSNG <em>letters</em></pre>
<p>Sets the default type for variables starting with <code><em>letters</em></code> to single (<code>!</code>). 
This is the type that is assumed if no type character is specified. <code><em>letters</em></code> 
are letters of the alphabet separated by commas or ranges specified with a 
dash: for example, <code>DEFSNG A,B,C-Z</code>. <code>DEFSNG A-Z</code> is the default setting.</p>


<h3><code>DEFSTR</code> statement</h3>
<pre>DEFSTR <em>letters</em></pre>
<p>Sets the default type for variables starting with <code><em>letters</em></code> to string (<code>$</code>). 
This is the type that is assumed if no type character is specified. <code><em>letters</em></code> 
are letters of the alphabet separated by commas or ranges specified with a 
dash: for example, <code>DEFSTR A,B,C-Z</code>.</p>


<h3><code>DEF SEG</code> statement</h3>
<pre>DEF SEG [=<em>address</em>]</pre>
<p>Sets the memory segment to be used by <code>BLOAD</code>, <code>BSAVE</code>, <code>CALL</code>, <code>PEEK</code>, <code>POKE</code>, or <code>USR</code>.
<code><em>address</em></code> is a numeric expression in <code>[-32768&mdash;65535]</code>.
<h4>Notes</h4>
<ul><li>
   If <code><em>address</em></code> is negative, it is interpreted as its two's complement.
</li><li>
   If <code><em>address</em></code> is not specified, the segment is set to the GW-BASIC data
    segment.
</li></ul>
<h4>Errors</h4>
<ul><li>
 <code><em>address</em></code> has a string value: <code>Type mismatch</code>.
</li><li>
 <code><em>address</em></code> is not in <code>[-32768&mdash;65535]</code>: <code>Overflow</code>.
</li></ul>


<h3><code>DEF USR</code> statement</h3>
<pre>DEF USR[<em>n</em>] = <em>address</em></pre>
<p>Does nothing. </p>
<h4>Parameters</h4>
<ul><li>
<code><em>n</em></code> is a digit between 0 and 9 inclusive. 
</li><li>
<code><em>address</em></code> is a numeric expression in <code>[-32768&mdash;65535]</code>.
</li></ul>
<h4>Notes</h4>
<ul><li>
   In GW-BASIC, this statement sets the starting address of an assembly-language function. 
</li><li>
    This statement is not implemented in PC-BASIC.
</li><li>
   If <code><em>address</em></code> is negative, it is interpreted as its two's complement.
</li></ul>
<h4>Errors</h4>
<ul><li>
 <code><em>n</em></code> is not a digit in <code>[0&mdash;9]</code>: <code>Syntax error</code>.
</li><li>
 <code><em>address</em></code> has a string value: <code>Type mismatch</code>.
</li><li>
 <code><em>address</em></code> is not in <code>[-32768&mdash;65535]</code>: <code>Overflow</code>.
</li></ul>

 
<h3><code>DELETE</code> statement</h3>
<pre>
DELETE [<em>line_number_0</em> | .] - [<em>line_number_1</em> | .]
DELETE [<em>line_number_0</em> | .]
</pre>
<p>Deletes a range of lines from the program.
Also stops program execution and returns control to the user.</p>
<h4>Parameters</h4>
<ul><li>
<code><em>line_number_0</code></em> and 
<code><em>line_number_1</code></em> are line numbers in the range <code>[0&mdash;65529]</code>, specifying the inclusive range of line numbers to delete.
</li><li>
A <code>.</code> indicates the last line edited.
</li><li>
If the start point is omitted, the range will start at the start of the program.
</li><li>
If the end point is omitted, the range will end at the end of the program.
</li><li>
If no range is specified, the whole program will be deleted.
</li></ul>
<h4>Errors</h4>
<ul><li>
<code><em>line_number_0</code></em> or 
<code><em>line_number_1</code></em> is greater than <code>65529</code>: <code>Syntax error</code>.
</li><li>
The range specified does not include any program lines stored: <code>Illegal function call</code>.
</li></ul>
    
    
<h3><code>DIM</code> statement</h3>
<pre>DIM <em>name</em> { ( | [ } <em>limit_0</em> [, <em>limit_1</em> [, ...] ] { ) | } ]
</pre>
<p>Allocates memory for arrays. 
The <code>DIM</code> statement also fixes the number of indices of the array. 
An array can only be allocated once; to re-allocate an array, <code>ERASE</code> or 
 <code>CLEAR</code> must be executed first. 
If an array is first used without a <code>DIM</code> statement, it is automatically allocated with its maximum indices set at <code>10</code>
for each index position used. If an array's <code>DIM</code> statement specifies no indices,
 it is allocated with a single index with maximum <code>10</code>.
The least index allowed is determined by <code>OPTION BASE</code>.
<h4>Parameters</h4>
<ul><li>
<code><em>name</em></code> is a legal variable name
specifying the array to be allocated. 
</li><li>
<code><em>limit_0</em>, <em>limit_1</em>, ...</code> are numeric 
expressions that specify the greatest index allowed at that position. 
</li></ul>
<h4>Notes</h4>
<ul><li>
Mixed brackets are allowed. 
</li><li>
   The size of arrays is limited by the available BASIC memory.
</li><li>
   The maximum number of indices is, theoretically, <code>255</code>. In practice,
    it is limited by the 255-byte limit on the length of program lines.
</li></ul>
<h4>Errors</h4>
<ul><li>
<code><em>name</em></code> has already been dimensioned: <code>Duplicate definition</code>.
</li><li>
An index is empty: <code>Syntax error</code>.
</li><li>
An index is missing at the end: <code>Missing operand</code>.
</li><li>
<code><em>limit_0</em>, <em>limit_1</em>, ...</code> have a string value: <code>Type mismatch</code>.
</li><li>
<code><em>limit_0</em>, <em>limit_1</em>, ...</code> are not within <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
</li><li>
<code><em>limit_0</em>, <em>limit_1</em>, ...</code> are negative: <code>Illegal function call</code>.
</li><li>
The array exceeds the size of available variable
    space:    <code>Out of memory</code>.
    </li></ul>


<h3><code>DRAW</code> statement</h3>
<pre>DRAW <em>gml_string</em></pre>
<p>Draws the shape specified by <code><em>gml_string</em></code>, a string expression in Graphics Macro Language (GML). </p>
<h4>GML reference</h4>
<dl>
<dt>Movement commands</dt>
<dd>
    <pre>[B][N] <em>movement</em> </pre>
    where the default is to move and draw; the optional prefixes mean:
    <table>
    <tr>
    <td><code>B</code></td>
    <td>move but do not plot</td>
    </tr><tr>
    <td><code>N</code></td>
    <td>return to original point after move</td>
    </tr>
    </table>
    and <code><em>movement</em></code> is one of:
    <table>
    <tr>
    <td><code>U[<em>n</em>]</code></td>
    <td>up <code><em>n</em></code> steps</td>
    </tr><tr>
    <td><code>L[<em>n</em>]</code></td>
    <td>left <code><em>n</em></code> steps</td>
    </tr><tr>
    <td><code>D[<em>n</em>]</code></td>
    <td>down <code><em>n</em></code> steps</td>
    </tr><tr>
    <td><code>R[<em>n</em>]</code></td>
    <td>right <code><em>n</em></code> steps</td>
    </tr><tr>
    <td><code>E[<em>n</em>]</code></td>
    <td>up and right <code><em>n</em></code> steps</td>
    </tr><tr>
    <td><code>F[<em>n</em>]</code></td>
    <td>down and right <code><em>n</em></code> steps</td>
    </tr><tr>
    <td><code>G[<em>n</em>]</code></td>
    <td>down and left <code><em>n</em></code> steps</td>
    </tr><tr>
    <td><code>H[<em>n</em>]</code></td>
    <td>up and left <code><em>n</em></code> steps</td>
    </tr><tr>
    <td><code>M{+|-}<em>x</em>,[+|-]<em>y</em></code></td>
    <td>move (<code><em>x</em></code>,<code><em>y</em></code>) steps</td>
    </tr><tr>
    <td><code>M<em>x</em>,<em>y</em></code></td>
    <td>move to view region coordinate (<code><em>x</em></code>,<code><em>y</em></code>) </td>
    </tr></table>
    <p>where <code><em>n</em></code>, <code><em>x</em></code>, <code><em>y</em></code> are integers in <code>[0&mdash;9999]</code>. 
    Where optional, <code><em>n</em></code> defaults to <code>1</code>.
</dd>
<dt>Scale commands</dt>
<dd>
    <table><tr>
    <td><code>S<em>n</em></code></td>
    <td>set the step size to <code><em>n</em>/4</code>. The default step size is 1 pixel.  
                <code><em>n</em></code> is an integer in <code>[1&mdash;255]</code>
    </td>
    </tr><tr>
    <td><code>TA<em>n</em></code></td>
    <td>
        set the angle to <code><em>n</em></code> degrees. The default angle is 0 degrees.
                <code><em>n</em></code> is an integer in <code>[-360&mdash;360]</code>
    </td>
    </tr><tr>
    <td><code>A<em>n</em></code></td>
    <td>    
        set the angle to 0 for <code><em>n</em>=0</code>, 
                90 for <code><em>n</em>=1</code>,
                180 for <code><em>n</em>=2</code>, 
                270 for <code><em>n</em>=3</code>.    
                <code><em>n</em></code> is an integer in <code>[0&mdash;3]</code>
    </td>
    </tr></table>
</dd>
<dt>Colour commands</dt>
<dd>
    <table><tr>
    <td><code>C<em>n</em></code></td>
    <td>      set the foreground attribute to <code><em>n</em></code>. See <code>COLOR</code>. </td>
    </tr><tr>
    <td><code>P<em>n</em>,<em>b</em></code></td>
    <td>flood fill with attribute <code><em>n</em></code> and boundary attribute <code><em>b</em></code>. See <code>PAINT</code>.
    </tr></table>
</dd>
<dt>Subroutine command</dt>
<dd>
    <table><tr>
    <td><code>X<em>s</em></code></td>
    <td>      execute a substring</td>
    </tr></table>
    <p><code><em>s</em></code> is one of the following:</p>
    <ul><li>
       a string variable name followed by semicolon (<code>;</code>)
    </li><li>
       the result of <code>VARPTR$()</code> on a string variable
    </li></ul>
</dd>
</dl>
    
<p>Numeric variables <code><em>n</em></code>, <code><em>x</em></code>, <code><em>y</em></code>, <code><em>b</em></code> in the commands above can be:</p>
<ul><li>
an integer literal, e.g. <code>DRAW "U100"</code>
</li><li>
a numeric variable name <code><em>var</em></code> preceded by <code>=</code> and followed by <code>;</code> e.g. <code>DRAW "U=VAR;"</code>
</li><li>
    the result of <code>VARPTR$(<em>var</em>)</code> preceded by <code>=</code>.  For example, <code>DRAW "U=" + VARPTR$(VAR)</code>
</ul>
<h4>Notes</h4>
<ul><li>
   The <code>CLS</code> statement resets the step size to 1 pixel, angle to 0 degrees and position to the
    centre of the view region.                 
</li><li>
   The value <code><em>n</em></code> in the <code>TA</code>, <code>A</code> and <code>C</code> command can be left out but <em>only</em> if the 
    command is terminated by a semicolon. <code><em>n</em></code> defaults to <code>0</code>.
</li></ul>
<h4>Errors</h4>
<ul><li>
 <code><em>gml_string</em></code> has a numeric value: <code>Type mismatch</code>.
</li><li>
 <code><em>gml_string</em></code> has errors in the GML: <code>Illegal function call</code>.
</li><li>
A variable referenced in the GML string is of incorrect type: <code>Type mismatch</code>.
</li></ul>


<h3><code>EDIT</code> statement</h3>
<pre>EDIT {<em>line_number</em> | .}</pre>
<p>
Displays the specified program line with the cursor positioned for editing.
<code><em>line_number</em></code> must be a line that exists in the program, or a period (.) to 
indicate the last line stored.</p>
<h4>Errors</h4>
<ul><li>
No line_number is specified: <code>Undefined line number</code>.
</li><li>
More characters are written after the line number: <code>Illegal function call</code>.
</li><li>
<code><em>line_number</em></code> is not in <code>[0&mdash;65529]</code>: <code>Illegal function call</code>.
</li><li>
The specified line number does not exist: <code>Undefined line number</code>.
</li></ul>

<h3><code>ELSE</code> statement</h3>
<pre>ELSE [<em>anything</em>]</pre>
<p>
Unless part of an <code>IF</code> statement on the same line, anything after <code>ELSE</code> is ignored
in the same way as after <code>'</code> or <code>:REM</code>. No colon <code>:</code> preceding
the <code>ELSE</code> statement is necessary. See <code>IF</code> for normal usage.</p>


<h3><code>END</code> statement</h3>
<pre>END</pre>
<p>
Closes all files, stops program execution and returns control to the user.
No message is printed. It is possible to resume execution at the next statement
using <code>CONT</code>.
</p>

<h3><code>ENVIRON</code> statement</h3>
<pre>ENVIRON <em>command_string</em></pre>
<p>Sets a shell environment variable.</p>
<h4>Parameters</h4>
<p> <code><em>command_string</em></code> is a string
expression of one of the following forms:
<table><tr>
<td><code>"<em>VARIABLE</em>=<em>VALUE</em>"</code></td>
<td>to set <code><em>VARIABLE</em></code> to <code><em>VALUE</em></code></td>
</tr><tr>
<td><code>"<em>VARIABLE</em>="</code></td>
<td>to unset <code><em>VARIABLE</em></code></td>
</tr></table></p>
<h4>Errors</h4>
<ul><li>
<code><em>command_string</em></code> has a numeric value: <code>Type mismatch</code>.
</li><li>
<code><em>command_string</em></code> is not of the required form: <code>Illegal function call</code>.
</li></ul>


<h3><code>ENVIRON$</code> function</h3>
<pre><em>value</em> = ENVIRON[ ]$(<em>x</em>)</pre>
<p>Returns an environment variable.</p>
<h4>Parameters</h4>
<p><code><em>x</em></code> is an expression.</p>
<ul><li>
If <code><em>x</em></code> has a string value, returns the value for the environment variable <code><em>x</em></code> or the empty
string if no variable with the name <code><em>x</em></code> is set in the environment table.
</li><li>
If <code><em>x</em></code> has a numeric value, it must be in <code>[1&mdash;255]</code>. Returns the <code><em>x</em></code>th entry in
the environment table.
</li></ul>
<h4>Errors</h4>
<ul><li>
<code><em>x</em></code> is the empty string: <code>Illegal function call</code>.
</li><li>
<code><em>x</em></code> is a number not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
</li><li>
<code><em>x</em></code> is a number not in <code>[1&mdash;255]</code>: <code>Illegal function call</code>.
</li></ul>


<h3><code>EOF</code> function</h3>
<pre><em>is_at_end</em> = EOF(<em>file_num</em>)</pre>
<p>Returns -1 if file with number <code><em>file_num</em></code> has reached end-of-file; 0 otherwise.
The file must be open in <code>INPUT</code> or <code>RANDOM</code> mode. <code>EOF(0)</code> returns 0.
</p>
<h4>Notes</h4>
<ul><li>
If <code><em>file_num</em></code> is open to <code>KYBD:</code>, performs a blocking read and returns -1 if
<code><b>CTRL</b></code>+<code><b>Z</b></code> is entered, 0 otherwise. The character entered is then echoed to
the console.
</li></ul>
<h4>Errors</h4>
<ul><li>
<code><em>file_num</em></code> has a string value</code>: <code>Type mismatch</code>.
</li><li>
<code><em>file_num</em></code> is a number not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
</li><li>
<code><em>file_num</em></code> is a number not in <code>[0&mdash;255]</code>: <code>Illegal function call</code>.
</li><li>
<code><em>file_num</em></code> is not 0 or the number of an open file:
    <code>Bad file number</code>.
</li><li>
The file with number <code><em>file_num</em></code> is in OUTPUT or APPEND mode:
    <code>Bad file mode</code>.
</li></ul>


<h3><code>ERASE</code> statement</h3>
<pre>ERASE <em>array_0</em> [, <em>array_1</em> [, ...] ]</pre>
<p>De-allocates arrays. The data stored in the
arrays is lost.</p>
<h4>Parameters</h4>
<ul><li>
<code><em>array_0</em>, <em>array_1</em> ...</code> are names of existing arrays. The names must be
specified without brackets.
</li></ul>
<h4>Errors</h4>
<ul><li>
No array names are given: <code>Syntax error</code>.
</li><li>
<code><em>array_0</em>, <em>array_1</em> ...</code> do not exist: <code>Illegal function call</code>.
</li><li>
If an error occurs, the arrays named before the error occurred are erased.
</li></ul>


<h3><code>ERDEV</code> function</h3>
<pre><em>zero</em> = ERDEV</pre>
<p>Returns 0.</p>
<h4>Notes</h4>
<ul><li>
   In GW-BASIC, returns the value of a device error.
</li><li>
This function is not implemented in PC-BASIC.
</li><li>
This function has no brackets.
</li></ul>


<h3><code>ERDEV$</code> function</h3>
<pre><em>empty</em> = ERDEV[ ]$</pre>
<p>Returns the empty string.</p>
<h4>Notes</h4>
<ul><li>
   In GW-BASIC, returns the device name of a device error.
</li><li>
This function is not implemented in PC-BASIC.
</li><li>
This function has no brackets.
</li></ul>


<h3><code>ERL</code> function</h3>
<pre><em>error_line</em> = ERL</pre>
<p>
Returns the line number where the last error was raised. </p>
<h4>Notes</h4>
<ul><li>
 If the error was
raised by a direct statement, returns 65535.
</li><li>
If no error has been raised,
returns 0.
</li><li>
This function has no brackets.
</li></ul>


<h3><code>ERR</code> function</h3>
<pre><em>error_code</em> = ERR</pre>
<p>
Returns the number of the last error. 
<h4>Notes</h4>
<ul><li>
If no error has been raised, returns 0.
</li><li>
   If the last error was a <code>Syntax error</code> raised by a direct statement, returns 0.
</li><li>
This function has no brackets.
</li></ul>


<h3><code>ERROR</code> statement</h3>
<pre>ERROR <em>error_number</em></pre>
<p>Raises the error with number <code><em>error_number</em></code>.
<h4>Parameters</h4>
<ul><li>
<code><em>error_number</em></code> is an expression 
with a numeric value. 
</li></ul>
<h4>Errors</h4>
<ul><li>
 <code><em>error_number</em></code> has a string value: <code>Type mismatch</code>.
</li><li>
 <code><em>error_number</em></code> is not in  <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
</li><li>
 <code><em>error_number</em></code> is not in <code>[1&mdash;255]</code>: <code>Illegal function call</code>.
</li></ul>


<h3><code>EXP</code> function</h3>
<pre><em>y</em> = EXP(<em>x</em>)</pre>
<p>Returns the exponential of <code><em>x</em></code>, i.e. <code>e</code> to the power <code><em>x</em></code>.
<h4>Parameters</h4>
<ul><li>
<code><em>x</em></code> is a number-
valued expression.
</li></ul>
<h4>Notes</h4>
<ul><li>
Unless PC-BASIC is run with the <code>--double</code> option, this function returns a single-precision
value.
</li><li>
   The return value sometimes differs in the least significant digit from GW-BASIC. For
    large values of <code><em>x</em></code>, the difference may be 3 digits.
</li></ul>
<h4>Errors</h4>
<ul><li>
 <code><em>x</em></code> has a string value: <code>Type mismatch</code>.
</li><li>
 <code><em>x</em></code> is larger than the natural logarithm of the maximum single-precision
    value: <code>Overflow</code>.
</li></ul>


<h3><code>EXTERR</code> function</h3>
<pre><em>zero</em> = EXTERR(<em>x</em>)</pre>
<p>Returns 0.
<h4>Parameters</h4>
<ul><li>
<code><em>x</em></code> is a numeric expression in <code>[0&mdash;3]</code>.
</li></ul>
<h4>Notes</h4>
<ul><li>
   In GW-BASIC, this function returns extended error information from MS-DOS.
</li><li>
    This function is not implemented in PC-BASIC.
</li></ul>
<h4>Errors</h4>
<ul><li>
 <code><em>x</em></code> is a string value: <code>Type mismatch</code>.
</li><li>
 <code><em>x</em></code> is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
</li><li>
 <code><em>x</em></code> is not in <code>[0&mdash;3]</code>: <code>Illegal function call</code>.
</li></ul>


<h3><code>FIELD</code> statement</h3>
<pre>FIELD [#] <em>file_number</em> [, <em>width_0</em> AS <em>name_0</em> [, <em>width_1</em> AS <em>name_1</em> [, ...] ] ]</pre>
<p>Assigns variables to the random-access record buffer. The record buffer is a
region of memory of length defined by the <code>OPEN</code> statement; the default record
length is 128 bytes. The <code>FIELD</code> statement assigns a portion of this region to
one or more fixed-length string variables, so that the value of these strings
is whatever happens to be in the record buffer at that location. 
<h4>Notes</h4>
<ul><li>
A <code>FIELD</code> statement
without any variables specified has no effect.
</li><li>
Another  <code>FIELD</code> statement on the same file will specify an alternative mapping of the
same file buffer; all mappings will be in effect simultaneously.
</li><li>
A subsequent assignment or <code>LET</code> or <code>MID$</code> statement on <code><em>name_0</em> , <em>name_1</em> ...</code> will dis-
associate the string variable from the field buffer.
</li><li>
Use <code>LSET</code> or <code>RSET</code> to change
values in the field buffer.
</li><li>
Use <code>GET</code> to read values from the file into the field
buffer, changing the variables.
</li><li>
Use <code>PUT</code> to write the field buffer to the file.
</li></ul>
<h4>Parameters</h4>
<ul><li>
<code><em>file_number</em></code> is a numeric expression that yields the number of an open random-access file. The <code>#</code> is optional and has no effect.
</li><li>
<code><em>width_0</em>, <em>width_1</em>, ...</code> are numeric
expressions giving the length of the string variables
</li><li>
<code><em>name_0</em> , <em>name_1</em> ...</code> are valid
string variable names.
</li></ul>
<h4>Errors</h4>
<ul><li>
<code><em>file_number</em></code> is not in <code>[0&mdash;255]</code>: <code>Illegal function call</code>.
</li><li>
<code><em>file_number</em></code> is not the number of an open file:
<code>Bad file number</code>.
</li><li>
<code><em>file_number</em></code> is open under a mode other than <code>RANDOM</code>:
<code>Bad file mode</code>.
</li><li>
The statement ends in a comma: <code>Missing operand</code>.
</li><li>
No file number is specified: <code>Missing operand</code>.
</li><li>
The lengths in a <code>FIELD</code> statement add up to a number larger than the
record length of the field buffer: <code>Field overflow</code>.
</li><li>
<code><em>name_0</em> , <em>name_1</em> ...</code> specify a non-string variable: <code>Type mismatch</code>.
</li></ul>


<h3><code>FILES</code> statement</h3>
<pre>FILES [<em>path_and_filter</em>]</pre>
<p>Displays the files fitting the specified filter in the specified directory. If
<code><em>path_and_filter</em></code> is not specified, displays all files in the current working
directory. </p>
<h4>Parameters</h4>
<ul><li>
<code><em>path_and_filter</em></code> is a string expression that
consists of two optional parts: the first part is the path to the directory; 
the second part is the filename filter.
</li></ul>
<h4>Notes</h4>
<ul><li>
The filename filter consists of file name
parts and the following wildcards:
<table><tr>
<td><code>?</code></td>
<td>matches any character but not the <code>\</code> or <code>.</code>
</td>
</tr><tr>
<td><code>*</code></td>
<td>matches any series of characters excluding <code>\</code> or <code>.</code></td>
</tr></table>
</li><li>
A filter
will only match MS-DOS style 8.3 all-uppercase filenames.
The path directories, however, can be case sensitive and longer according to
the host OS's standards.
</li><li>
If all files in a
specified directory are required, end the directory name with a backslash <code>\</code>.
</li></ul>
<h4>Errors</h4>
<ul><li>
 <code><em>path_and_filter</em></code> has a numeric value: <code>Type mismatch</code>.
</li><li>
 <code><em>path_and_filter</em></code> is the empty string: <code>Bad file name</code>.
</li><li>
The specified filter does not match any files: <code>File not found</code>.
</li></ul>


<h3><code>FIX</code> function</h3>
<pre><em>whole</em> = FIX(<em>number</em>)</pre>
<p>Returns <code><em>number</em></code> truncated towards zero.</p>
<h4>Parameters</h4>
<ul><li>
<code><em>number</em></code> is a numeric expression.
</li></ul>
<h4>Notes</h4>
<ul><li>
 <code>FIX</code> truncates towards zero: it removes the fractional part. By contrast, <code>INT</code>
    truncates towards negative infinity. For negative <code><em>x</em></code>, <code>FIX(<em>x</em>)-INT(<em>x</em>)=1</code>.
</li></ul>
<h4>Errors</h4>
<ul><li>
<code><em>number</em></code> is a string expression: <code>Type mismatch</code>.
</li></ul>


<h3><code>FN</code> function</h3>
<pre><em>result</em> = FN[ ]<em>name</em> (<em>arg_0</em> [, <em>arg_1</em> [, ...] ])</pre>
<p>Evaluates a user-defined function.
Spaces between <code>FN</code> and <code><em>name</em></code> are optional.
<h4>Parameters</h4>
<ul><li>
<code><em>name</em></code> is the name of a previously defined function.
</li><li>
<code><em>arg_0</em>, <em>arg_1</em>, ...</code> are expressions, given as parameters to the function.
</li></ul>
<h4>Errors</h4>
<ul><li>
No function named <code><em>name</em></code> is defined:
    <code>Undefined user function</code>.
</li><li>
The number of parameters differs from the function definition:
    <code>Syntax error</code>.
</li><li>
The type of one or more parameters differs from the function definition:
    <code>Type mismatch</code>.
</li></ul>


<h3><code>FOR</code> statement</h3>
<pre>FOR <em>loop_var</em> = <em>start</em> TO <em>stop</em> [STEP <em>step</em>]</pre>
<p>Initiates a <code>FOR&mdash;NEXT</code> loop.</p>
<p>Initially, <code><em>loop_var</em></code> is set to <code><em>start</em></code>. Then, the statements between the <code>FOR</code>
statement and the <code>NEXT</code> statement are executed and <code><em>loop_var</em></code> is incremented by
<code><em>step</em></code> (if <code><em>step</em></code> is not specified, by 1). This is repeated until <code><em>loop_var</em></code>
has become greater than <code><em>stop</em></code>. Execution then continues at the statement
following <code>NEXT</code>. The value of <code><em>loop_var</em></code> equals <code><em>stop</em>+<em>step</em></code> after the loop.</p>
<h4>Parameters</h4>
<ul><li>
<code><em>loop_var</em></code> is a valid numeric variable name.
</li><li>
<code><em>start</em></code>, <code><em>stop</em></code> and <code><em>step</em></code> are numeric expressions.
</li></ul>
<h4>Errors</h4>
<ul><li>
No <code>NEXT</code> statement is found to match the <code>FOR</code> statement: <code>FOR without NEXT</code>
    occurs at the <code>FOR</code> statement.
</li><li>
 <code><em>loop_var</em></code> is a string variable name or <code><em>start</em></code>, <code><em>stop</em></code>, or <code><em>end</em></code> has a string value:
    <code>Type mismatch</code>.
</li><li>
 <code><em>loop_var</em></code> is an array element: <code>Syntax error</code> .
</li></ul>
        

<h3><code>FRE</code> function</h3>
<pre><em>free_mem</em> = FRE(<em>x</em>)</pre>
<p>Returns the available BASIC memory.</p>
<h4>Parameters</h4>
<p><code><em>x</em></code> is an expression.</p>
<ul><li>
If <code><em>x</em></code> has a numeric value, it is ignored.
</li><li>
If <code><em>x</em></code> has a string value, garbage collection is performed
before returning available memory.
</li></ul>


<h3><code>GET</code> statement (random-access files)</h3>
<pre>GET [#] <em>file_number</em> [, <em>record_number</em>]</pre>
<p>Read a record from the random-access file <code><em>file_number</em></code> at position
<code><em>record_number</em></code>.
The record can be accessed through the <code>FIELD</code> variables or through <code>INPUT$</code>,
 <code>INPUT</code> or <code>LINE INPUT</code>.
<h4>Parameters</h4>
<ul><li>
<code><em>file_number</em></code> is a numeric expression that yields the number
of an open random-access file. The <code>#</code> is optional and has no effect.
</li><li>
<code><em>record_number</em></code> is a numeric expression in <code>[1&mdash;33554432]</code> (<code>2^25</code>), and is interpreted as the record number.
</li></ul>
<h4>Notes</h4>
<ul><li>
If the record number is beyond the end of the file, the file buffer is 
    filled with null bytes.
</li></ul>
    <h4>Errors</h4>
<ul><li>
<code><em>record_number</em></code> is not in <code>[1&mdash;33554432]</code>: <code>Bad record number</code>.
</li><li>
<code><em>file_number</em></code> is not in <code>[0&mdash;255]</code>: <code>Illegal function call</code>.
</li><li>
<code><em>file_number</em></code> is not the number of an open file:
    <code>Bad file number</code>.
</li><li>
<code><em>file_number</em></code> is open under a mode other than <code>RANDOM</code>:
    <code>Bad file mode</code>.
</li><li>
<code><em>file_number</em></code> is not specified: <code>Missing operand</code>.
</li></ul>

<h3><code>GET</code> statement (serial communications)</h3>
<pre>GET [#] <em>com_file_number</em> [, <em>number_bytes</em>]</pre>
<p>Read <code><em>number_bytes</em></code> bytes from the communications buffer opened under file
number <code><em>com_file_number</em></code>.
The record can be accessed through the <code>FIELD</code> variables or through <code>INPUT$</code>,
 <code>INPUT</code> or <code>LINE INPUT</code>.</p>
<h4>Parameters</h4>
<ul><li>
<code><em>file_number</em></code> is a numeric expression that yields the number
of a file open to a <code>COM</code> device. The <code>#</code> is optional and has no effect.
</li><li>
 <code><em>number_bytes</em></code> is a numeric expression between <code>1</code>
and the <code>COM</code> buffer length, inclusive.
</li></ul>
<h4>Notes</h4>
<ul><li>
   If <code><em>bytes</em></code> is <code>32768</code> or greater, GW-BASIC hangs. This functionality is not implemented in PC-BASIC.
</li><li>
   In GW-BASIC, <code>Device I/O error</code> is raised for overrun error, framing error,
    and break interrupt. <code>Device fault</code> is raised if DSR is lost during I/O. 
    <code>Parity error</code> is raised if parity is enabled and incorrect parity is
    encountered. This is according to the manual; it is untested.
</li></ul>
<h4>Errors</h4>
<ul><li>
<code><em>bytes</em></code> is less than 1: <code>Bad record number</code>
</li><li>
<code><em>bytes</em></code> is less than <code>32768</code> and greater than the <code>COM</code> buffer length: <code>Illegal function call</code>.
</li><li>
<code><em>com_file_number</em></code> is not specified: <code>Missing operand</code>.
</li><li>
<code><em>com_file_number</em></code> is not in <code>[0&mdash;255]</code>: <code>Illegal function call</code>.
</li><li>
<code><em>com_file_number</em></code> is not the number of an open file:
    <code>Bad file number</code>.
</li><li>
If the serial input buffer is full, i.e. <code>LOF(<em>com_file_number</em>) = 0</code>, and
    <code>LOC(<em>com_file_number</em>) = 255</code>: <code>Communication buffer overflow</code>
</li><li>
   If the carrier drops during <code>GET</code>, hangs until the <code><b>Ctrl</b></code>+<code><b>Break</b></code> key is pressed.
</li></ul>
        
    
<h3><code>GET</code> statement (graphics)</h3>
<pre>GET (<em>x0</em>, <em>y0</em>) - [STEP] (<em>x1</em>, <em>y1</em>), <em>array_name</em></pre>
<p>Stores a rectangular area of the graphics screen in an array.
The area stored is a rectangle parallel to the screen edges, bounded by the
top-left and bottom-right coordinates <code><em>x0</em></code>,<code><em>y0</em></code> and <code><em>x1</em></code>,<code><em>y1</em></code>. If <code>STEP</code> is
specified, <code><em>x1</em></code>,<code><em>y1</em></code> is an offset from <code><em>x0</em></code>,<code><em>y0</em></code>. The area is such that these
corner points are inside it.</p>
<p>The image stored in the array can then be put on the screen using PUT. For the
purposes of <code>GET</code>, any array is considered a string of bytes. The byte size of an
array can be calculated as <code><em>number_elements</em> * <em>byte_size</em></code> with <code><em>byte_size</em></code> equal to
<code>2</code> for integers (<code>%</code>), 4 for single (<code>!</code>) and 8 for double (<code>#</code>).
Array byte size for
string is 3, but string arrays are not allowed in <code>GET</code>. For calculating the
number of elements, keep in mind that <code>OPTION BASE 0</code> is the default; in which
case an array with maximum index 10 has 11 elements. This works through in
multidimensional arrays.</p>

<p>The array format is as follows:</p>
<table>

<tr>
<th>Byte</th>
<th>Contains</th>
</tr><tr>
<td>0, 1</td>
<td>Number of x pixels, unsigned int. In <code>SCREEN 1</code>, this value is doubled.</td>
</tr><tr>
<td>2, 3</td>
<td>Number of y pixels, unsigned int.
</tr><tr>
<td>4&mdash;</td>
<td>Pixel data. Data is arranged in 2-byte words. The first 16-bit word holds the bit 0 of
    the first 16 pixels on the top row. The second word holds the second bit,
    etc. Data is word-aligned at the end of each row. Thus, in a screen mode
    with 4 bits per pixel, the first row takes at least 8 bytes (4 words), even
    if it consists of only one pixel. The number of bits per pixel depends on
    the <code>SCREEN</code> mode.
</td>
</tr>
</table>
<h4>Parameters</h4>
<ul><li>
<code><em>array_name</em></code> is the name of a numeric array dimensioned with enough space to store the area.
</li><li>
 <code><em>x0</em></code>, <code><em>y0</em></code>, <code><em>x1</em></code>, <code><em>y1</em></code> are numeric expressions.
</li></ul>
<h4>Notes</h4>
<ul><li>
   In PCjr/Tandy mode, in <code>SCREEN 6</code>, <code>GET</code> stores an area of <em>twice the width</em>
    of the specified rectangle.
</li></ul>
<h4>Errors</h4>
<ul><li>
The array does not exist: <code>Illegal function call</code>.
</li><li>
<code><em>array_name</em></code> refers to a string array: <code>Type mismatch</code>.
</li><li>
The area is too large for the array: <code>Illegal function call</code>.
</li><li>
<code><em>x0</em></code>, ... <code><em>y1</em></code> are string expressions: <code>Type mismatch</code>.
</li><li>
<code><em>x0</em></code>, ... <code><em>y1</em></code> are not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
</li><li>
<code><em>x0</em></code>, ... <code><em>y1</em></code> are outside the current <code>VIEW</code> or <code>WINDOW</code>:
    <code>Illegal function call</code>
</li></ul>

<h3><code>GOSUB</code> statement</h3>
<pre>GO[ ]SUB <em>line_number</em> [<em>anything</em>]</pre>
<p>Jumps to a subroutine at <code><em>line_number</em></code>. The next <code>RETURN</code> statement jumps back to
the statement after <code>GOSUB</code>. Anything after <code><em>line_number</em></code> until the end of the
statement is ignored. If executed from a direct line, <code>GOSUB</code> runs the subroutine and
the following <code>RETURN</code> returns execution to the direct line.
<h4>Parameters</h4>
<ul><li>
<code><em>line_number</em></code> is an existing line number literal.
</li><li>
Further characters on
the line are ignored until end of statement.
</li></ul>
<h4>Notes</h4>
<ul><li>
   If no <code>RETURN</code> is encountered, no problem.
</li><li>
One optional space is allowed between <code>GO</code> and <code>SUB</code>; it will not be retained in
    the program.
</li></ul>
<h4>Errors</h4>
<ul><li>
   If <code><em>line_number</em></code> does not exist: <code>Undefined line number</code>.
</li><li>
   If <code><em>line_number</em></code> is greater than <code>65529</code>, only the first 4 characters are
    read (e.g. <code>6553</code>)
</li></ul>


<h3><code>GOTO</code> statement</h3>
<pre>GO[ ]TO <em>line_number</em> [<em>anything</em>]</pre>
<p>Jumps to <code><em>line_number</em></code>.  Anything after <code><em>line_number</em></code> until the end of the 
statement is ignored. If executed from a direct line, <code>GOTO</code> starts execution of the program at the specified line.
<h4>Parameters</h4>
<ul><li>
<code><em>line_number</em></code> is an existing line number literal.
</li><li>
Further characters on
the line are ignored until end of statement.
</li></ul>
<h4>Notes</h4>
<ul><li>
   Any number of optional spaces is allowed between <code>GO</code> and <code>TO</code>, but they will
    not be retained in the program.
</li></ul>
<h4>Errors</h4>
<ul><li>
<code><em>line_number</em></code> does not exist: <code>Undefined line number</code>.
</li><li>
   If <code><em>line_number</em></code> is greater than <code>65529</code>, only the first 4 characters are
    read (e.g. <code>6553</code>)
</li></ul>

HEX$ function
hex_repr = HEX(x)
----------------
Returns a string with the hexadecimal representation of <code><em>x</em></code>. <code><em>x</em></code> must be a 
numeric expression between -32768 and 65535, inclusive. Values for 
negative <code><em>x</em></code> are shown as two's-complement. 
<h4>Errors</h4>
-   If <code><em>x</em></code> is not in <code>[-32768&mdash;65535]</code>, <code>Overflow</code> .
-   If <code><em>x</em></code> has a string value, <code>Type mismatch</code> .


IF statement
IF truth_value [,] { THEN | GOTO } [ statements_1 | line_number_1 [anything] ]
    [ ELSE [ statements_0 | line_number_0 [anything] ] ]
------------
If 'truth_value' is non-zero, executes statements_1 / jumps to line_number_1. 
If it is zero, executes statements_0 or jumps to line_number_1. 'truth_value' 
is a numeric expression. The comma is optional and ignored. 
'line_number_0' and 'line_number_1' are valid existing line numbers. 
Statements 'statements_0' and 'statements_1' can be compound statements with
one or more colons (:) separating single statements. The compound statements 
can contain nested IF..THEN..ELSE statements. ELSE clauses are optional; they
are bound to the innermost free IF statement if nested. Additional ELSE 
clauses that have no matching IF are ignored. All clauses must be on the same 
program line.
<h4>Notes</h4>
-   THEN and GOTO are interchangeable; which one is chosen is independent
    of whether a statement or a line number is given. GOTO PRINT 1 is fine.
-   As in GOTO, anything after the line number is ignored.
-   If 'truth_value' has a string value: <code>Type mismatch</code>.
    
    
INKEY$ function
key = INKEY$
---------------
Returns one key-press from the keyboard buffer. If the keyboard buffer is 
empty, returns the empty string. Otherwise, the return value is either a one
character string or a two-character string of which the first is CHR$(0) and
the second a keyboard scancode.
The hex values for keyboard scancodes returned by INKEY$ are:
<pre>
    <UP>            48
    <DOWN>          50
    <RIGHT>         4D
    <LEFT>          4B
    <code><b>Ins</b></code>        52
    <code><b>Del</b></code>        53
    <code><b>Home</b></code>          47
    <code><b>End</b></code>           4F
    <PAGEUP>        49
    <PAGEDOWN>      51
    <F1>            3B
    <F2>            3C
    <F3>            3D
    <F4>            3E
    <F5>            3F
    <F6>            40
    <F7>            41
    <F8>            42
    <F9>            43
    <F10>           44
    <PRINT>         37
    <CTRL+RIGHT>    74
    <CTRL+LEFT>     73
    <CTRL+HOME>     77
    <CTRL+END>      75
    <CTRL+PAGEUP>   84
    <CTRL+PAGEDOWN> 76
    <CTRL+2>        03
    <CTRL+9>        84
    <CTRL+F2>       5F
    <CTRL+F3>       60
</pre>

INP function
code = INP(port)
------------
Returns the value of an emulated machine port.
<code><em>port</em></code> is a numeric expression with a value between 0 and 65535, inclusive.
If <code><em>port</em></code>==&H60:
    Returns the keyboard scancode for the last key pressed.
    The scancodes returned by INP(&H60) are listed below. If the key is 
    currently down, the scancode is returned; if it has been released, 
    the scancode is incremented by 128. Scancodes returned by INP(&H60):
    <pre>
        key         scancode
        <code><b>Esc</b></code>       01
        <1>         02
        <2>         03
        <3>         04
        <4>         05
        <5>         06
        <6>         07
        <7>         08
        <8>         09
        <9>         0A
        <0>         0B
        <->         0C
        <=>         0D
        <BACKSPACE> 0E
        <code><b>Tab</b></code>       0F
        <q>         10
        <w>         11
        <e>         12
        <r>         13
        <t>         14
        <y>         15
        <code><b>U</b></code>         16
        <code><b>I</b></code>         17
        <code><b>O</b></code>         18
        <code><b>P</b></code>         19
        <[>         1A
        <]>         1B
        <code><b>Enter</b></code>     1C
        <code><b>Ctrl</b></code>      1D
        <a>         1E
        <code><b>S</b></code>         1F
        <code><b>D</b></code>         20
        <f>         21
        <g>         22
        <h>         23
        <j>         24
        <k>         25
        <l>         26
        <;>         27
        <'>         28
        <`>         29
        <LSHIFT>    2A
        <#>         2B
        <z>         2C
        <x>         2D
        <c>         2E
        <v>         2F
        <code><b>B</b></code>         30
        <n>         31
        <m>         32
        <,>         33
        <.>         34
        </>         35
        <RSHIFT>    36
        <PRTSC>     37
        <SYSRQ>     37
        <code><b>Alt</b></code>       38
        <SPACE>     39
        <code><b>Caps Lock</b></code>  3A
        <F1>        3B
        <F2>        3C
        <F3>        3D
        <F4>        3E
        <F5>        3F
        <F6>        40
        <F7>        41
        <F8>        42
        <F9>        43
        <F10>       44
        <code><b>Num Lock</b></code>   45
        <SCROLLOCK> 46
        <code><b>Home</b></code>      47
        <UP>        48
        <PGUP>      49
        <KEYPAD ->  4A
        <LEFT>      4B
        <KEYPAD 5>  4C
        <RIGHT>     4D
        <KEYPAD +>  4E
        <code><b>End</b></code>       4F
        <DOWN>      50
        <PGDN>      51
        <code><b>Ins</b></code>       52
        <code><b>Del</b></code>       53
    </pre>
If <code><em>port</em></code>==&H201:
    Returns the value of the game port (joystick port). This value is 
    constructed as follows:
        bit     meaning
        0       joystick 2 x-axis
        1       joystick 1 y-axis
        2       joystick 1 x-axis
        3       joystick 2 y-axis
        4       joystick 2 button 1
        5       joystick 1 button 2
        6       joystick 1 button 1
        7       joystick 2 button 2
    The button bits are 0 when the button is fired, 1 otherwise. The axis values
    are normally 0 but are set to 1 by OUT &H201, x and then fall back to 0 
    after a delay. The longer the delay, the higher the axis value. 
Returns zero for other <code><em>port</em></code> values.
<h4>Notes</h4>
-   Only a limited number of machine ports are emulated in PC-BASIC 3.23.
<h4>Errors</h4>
-   If <code><em>port</em></code> is not in <code>[-32768&mdash;65535]</code>, <code>Overflow</code> .
-   If <code><em>port</em></code> has a string value, <code>Type mismatch</code> .
        

INPUT statement (screen)
INPUT [;] [ prompt {;|,} ] var_0 [, var_1 [, ... ] ]
---------------
Prints 'prompt' to the screen and waits for the user to input values for var_0,
 ... . 'prompt' is a string literal. 'var_0', ... are variable names or 
fully indexed array elements.  The semicolon before the prompt, if present, 
stops a newline from being printed after the values have been entered.
If the prompt is followed by a semicolon, it is printed with a trailing ?. If 
the prompt is followed by a comma, no question mark is added. 
<h4>Notes</h4>
-   Values entered must be separated by commas. Leading and trailing whitespace
    is discarded.
-   String values can be entered with or without double quotes ("). 
-   If a string with a comma, leading or trailing whitespace is needed, 
    quotes are the only way to enter it. 
-   Between a closing quote and the comma at the end of the entry, only white-
    space is allowed.    
-   If quotes are needed in the string itself, the first character must be 
    neither a quote nor whitespace. It is not possible to enter a string that
    starts with a quote through INPUT.
-   If a given 'var_n' is a numeric variable, the value entered must be a valid
    number literal.
-   Characters beyond the 255th character of the screen line are discarded.    
<h4>Errors</h4>
-   If the value entered for a numeric variable is not a valid numeric literal,
    or the number of values entered does not match the number of variables in 
    the statement,
    ?REDO FROM START is printed and all values must be entered again. 
-   A <code>Syntax error</code> that is caused after the prompt is printed is only raised
    after the value shave been entered. No values are stored.
    

INPUT# statement (text files, devices, or random-access files)
INPUT # file_num, var_0 [, var_1 [, ...] ]
----------------
Reads string or numeric variables from a text file, device, or the FIELD buffer
of a random access file. <code><em>file_num</em></code> must be the number of a file open in 
INPUT mode or a device or random-access file open in <code>RANDOM</code> mode. 'var_0', ... 
are variable names or fully indexed array elements.   
<h4>Notes</h4>
-   The # is mandatory. There may or may not be whitespace between INPUT and #.        
-   String values can be entered with or without double quotes ("). 
-   Numeric values are terminated by space, LF, CR, comma.
-   Unquoted strings are terminated by LF, CR, comma.
-   Quoted strings are terminated by the closing quote.
-   Any entry is terminated by end-of-file &h1a or its 255th character.
-   Leading and trailing whitespace is discarded.
-   If the entry cannot be converted to the requested type, a zero value is
    returned.
-   If <code><em>file_num</em></code> is open to KYBD:, INPUT# reads from the keyboard until a
    return or comma is encountered (as in a file). Arrow keys and delete are
    passed as their control characters (NOT scancodes!) preceded by CHR$(&HFF).
<h4>Errors</h4>
-   If input is requested after the end of a text file has been reached or an
    EOF char has been encountered: INPUT PAST END.
-   If the last character of the field buffer is read: <code>Field overflow</code>.
-   If <code><em>file_num</em></code> is not an open file: <code>Bad file number</code>.
-   If <code><em>file_num</em></code> is less than zero: <code>Illegal function call</code>.
-   If <code><em>file_num</em></code> is greater than 32767: <code>Overflow</code>.
-   If <code><em>file_num</em></code> is not open for INPUT or <code>RANDOM</code>: <code>Bad file mode</code>.
-   If <code><em>file_num</em></code> is a string: <code>Type mismatch</code>.
    

INPUT$ function
chars = INPUT[ ]$(num_chars [, [#] file_num])
---------------
Returns a string of <code><em>num_chars</em></code> characters from the keyboard or a file. 
<code><em>num_chars</em></code> must be a numeric expression between 1 and 255, inclusive.
If <code><em>file_num</em></code> is provided, reads the string from a text file. <code><em>file_num</em></code> must
be a number valued expression that returns the number of a text file opened in
 INPUT mode. The hash is optional and has no effect.
<h4>Notes</h4>
-   This is a blocking read. It will wait for characters if there are none 
    in the buffer.
-   All control characters except <code><b>Ctrl</b></code>+<code><b>Break</b></code>, <code><b>Ctrl</b></code>+<code><b>Scroll Lock</b></code> and <code><b>Pause</b></code> 
    are passed to the string by INPUT$. <code><b>Ctrl</b></code>+<code><b>Break</b></code> and <code><b>Ctrl</b></code>+<code><b>Scroll Lock</b></code> break
    execution whereas <code><b>Pause</b></code> halts until another key is pressed (and not read).
-   When reading from the keyboard directly or through KYBD:, arrow keys, <code><b>Del</b></code>,
    <code><b>Home</b></code>, <code><b>End</b></code>, <PGUP>, <PGDN> are passed as NUL characters. Function keys
    are ignored if they are event-trapped, otherwise keyword replacement is
    active as normal.    
<h4>Errors</h4>
-   If <code><em>num_chars</em></code> is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
-   If <code><em>num_chars</em></code> is not in [1, 255]: <code>Illegal function call</code>.
-   If <code><em>file_num</em></code> is not an open file: <code>Bad file number</code>.
-   If <code><em>file_num</em></code> is less than zero: <code>Illegal function call</code>.
-   If <code><em>file_num</em></code> is greater than 32767: <code>Overflow</code>.
-   If <code><em>file_num</em></code> is not open for INPUT: <code>Bad file mode</code>.
-   If <code><em>num_chars</em></code> or <code><em>file_num</em></code> are strings: <code>Type mismatch</code>.
    
    
INSTR function
position = INSTR([start,] parent, child)
--------------
Returns the location of the first occurrence of the substring 'child' in 
'parent'. 'parent' and 'child' must be string expressions. If <code><em>start</em></code> is
provided, it must be a numeric expression between 1 and 255, specifying
the starting position from where to look; if not specified, the search starts 
at character 1.
<h4>Notes</h4>
-   If 'child' is not a substring of 'parent' occurring at or before <code><em>start</em></code>, 
    INSTR returns 0.
<h4>Errors</h4>
-   If <code><em>start</em></code> is not in [-32768, 32768]: <code>Overflow</code>.
-   If <code><em>start</em></code> is not in [1, 255]: <code>Illegal function call</code>.
-   If <code><em>start</em></code> has a string value or 'parent' or 'child' have number values, 
    raises <code>Type mismatch</code>.


INT function
whole = INT(number)
------------
Returns <code><em>number</em></code> truncated towards negative infinity.    
<code><em>number</em></code> must be a numeric expression.
<h4>Notes</h4>
-   While FIX truncates towards zero (i.e. removes the fractional part), INT
    truncates towards negative infinity. For negative <code><em>x</em></code>, FIX(x)-INT(x)==1.
<h4>Errors</h4>
-   If <code><em>number</em></code> is a string expression, <code>Type mismatch</code> .
 

IOCTL statement
IOCTL [#] file_num, control_string
---------------
Raises <code>Illegal function call</code>.
<h4>Notes</h4>
-   In GW-BASIC, IOCTL send a control string to a device. This is not 
    implemented in PC-BASIC 3.23.
<h4>Errors</h4>
-   If <code><em>file_num</em></code> is not an open file: <code>Bad file number</code>.
-   If <code><em>file_num</em></code> is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
-   If <code><em>file_num</em></code> has a string value: <code>Type mismatch</code>.
-   Otherwise: <code>Illegal function call</code>


IOCTL$ function
result = IOCTL[ ]$([#] file_num)
---------------
Raises <code>Illegal function call</code>.
<h4>Notes</h4>
-   In GW-BASIC, IOCTL$ reads the reply to IOCTL from a device. This is not 
    implemented in PC-BASIC 3.23.
<h4>Errors</h4>
-   If <code><em>file_num</em></code> is not an open file: <code>Bad file number</code>.
-   If <code><em>file_num</em></code> is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
-   If <code><em>file_num</em></code> has a string value: <code>Type mismatch</code>.
-   Otherwise: <code>Illegal function call</code>

    
KEY statement (string macro control)
KEY { ON | OFF | LIST }
-------------
Turns string macros ON or OFF; if LIST is specified, produces a list of
the 10 function keys with the string macros defined for those keys. Special 
characters are represented by their symbol equivalent in the loaded codepage;
some characters get a special representation. E.g. CHR$(13) is represented 
as a back arrow. 


KEY statement (string macro definition)
KEY key_id, string_value
-------------
Defines the string macro for key <code><em>key_id</em></code>. <code><em>key_id</em></code> must be a numeric 
expression in the range 1--10, inclusive. 'string_value' must be a string-
valued expression. Only the first 15 characters of 'string_value' are stored.
NOES:
-   IF <code><em>key_id</em></code> is not in the range [1, 10], the statement is interpreted as an
    event trapping key definition (see below).
<h4>Errors</h4>
-   If <code><em>key_id</em></code> is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
-   If <code><em>key_id</em></code> is not in [1, 255]: <code>Illegal function call</code>.
-   If <code><em>key_id</em></code> has a string value: <code>Type mismatch</code>.


KEY statement (event trapping control)
KEY ( key_id ) { ON | OFF | STOP } 
-------------
Controls event trapping of the key with identifier <code><em>key_id</em></code>. If ON is specified
event trapping is switched on; if OFF, off. STOP suspends event trapping until 
another KEY() ON is executed. Up to one event can be triggered during 
suspension, provided that event handling was switched on prior to suspension. 
he event triggered during suspension is handled immediately after the next ..ON
statement.
<code><em>key_id</em></code> must be a numeric expression in the range 1--20, inclusive. 
Keys 1--10 are F1--F10. Keys 11--14 are:
    11  <UP>
    12  <LEFT>
    13  <RIGHT>
    14  <DOWN>
Keys 15 to 20 are defined using the event trapping KEY definition statement
as described below.    
<h4>Errors</h4>
-   If <code><em>key_id</em></code> is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
-   If <code><em>key_id</em></code> is not in [0, 20]: <code>Illegal function call</code>.
-   If <code><em>key_id</em></code> has a string value: <code>Type mismatch</code>.
 

KEY statement (event trapping key definition)
KEY key_id, two_char_string
-------------
Defines the key to trap for <code><em>key_id</em></code>. <code><em>key_id</em></code> must be a numeric 
expression in the range 15--20, inclusive. 'string_value' must be a string-
valued expression of length 2. The first character is interpreted as a modifier
while the second character is interpreted as a scan code. See INP for scan
codes. Modifiers are:
    &h80    Extended
    &h40    <code><b>Caps Lock</b></code>
    &h20    <code><b>Num Lock</b></code>
    &h08    <code><b>Alt</b></code>
    &h04    <code><b>Ctrl</b></code>
    &h02    <code><b>Shift</b></code> (either side)
    &h01    <code><b>Shift</b></code> (either side)
<h4>Notes</h4>
-   If <code><em>key_id</em></code> is not in [15,20], no error is raised, but strange things can 
    happen in GW-BASIC: screen anomalies and crashes suggestive of unintended
    memory access. This is not implemented in PC-BASIC: such values are 
    ignored.
-   If <code><em>key_id</em></code> is in 1--10, the statement is interpreted as a string macro
    definition, see above.
<h4>Errors</h4>
-   If <code><em>key_id</em></code> is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
-   If <code><em>key_id</em></code> is not in [1, 255]: <code>Illegal function call</code>.
-   If <code><em>key_id</em></code> has a string value: <code>Type mismatch</code>.
-   If 'two_char_string' is longer than two: <code>Illegal function call</code>.
-   If 'two_char_string' has a numeric value: <code>Type mismatch</code>.


KILL statement
KILL file_path
--------------
Deletes a file. 'file_path' must be a string expression that specifies a
valid path to an existing file with MS-DOS path separators (\). The extension 
must be specified: no default extensions are assumed. KILL will first attempt 
to delete a file with the name exactly as provided; this is case-sensitive if
the file system is. If such a file does not exist, KILL attempts to delete the
UPPERCASE 8.3 variant of the file name; lacking that, it will match the first
8.3 name in lexicographic order.
<h4>Errors</h4>
-   If the file 'file_path' is open: FILE ALREADY OPEN
-   If the file or path 'file_path' does not exist: <code>File not found</code>
-   If the user has no write permission: PERMISSION DENIED
-   If a syntax error occurs after the closing quote, the file is removed 
    anyway.
-   If 'file_path' has a number value: <code>Type mismatch</code>.


LCOPY statement
LCOPY [num]
---------------
Does nothing. <code><em>num</em></code> is a numeric expression between 0 and 255, inclusive.
<h4>Notes</h4>
-   This statement does nothing in GW-BASIC. Presumably, it is left over from a
    statement in older versions of MS Basic that would copy the screen to the 
    printer.
<h4>Errors</h4>
-   If <code><em>num</em></code> is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
-   If <code><em>num</em></code> is not in <code>[0&mdash;255]</code>: <code>Illegal function call</code>.
-   If <code><em>num</em></code> has a string value: <code>Type mismatch</code>.


LEFT$ function
child = LEFT$(parent, num_chars)
--------------
Returns the leftmost <code><em>num_chars</em></code> characters of 'parent'. 'parent' must be a 
string expression. <code><em>num_chars</em></code> must be a numeric expression between 0 
and 255, inclusive. If <code><em>num_chars</em></code> is zero or 'parent' is empty, LEFT$ returns
an empty string "". If <code><em>num_chars</em></code> is greater than the length of 'parent', 
returns 'parent'.
<h4>Errors</h4>
-   If <code><em>num_chars</em></code> is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
-   If <code><em>num_chars</em></code> is not in <code>[0&mdash;255]</code>: <code>Illegal function call</code>.
-   If <code><em>num_chars</em></code> has a string value: <code>Type mismatch</code>.


LEN function
length = LEN(string)
--------------
Returns the number of characters in 'string'. 'string' is a string
expression.
<h4>Errors</h4>
-   If 'string' has a number value: <code>Type mismatch</code>.


LET statement
[LET] name = expression
-------------
Assigns the value of <code><em>expression</em></code> to the variable or array element <code><em>name</em></code>. 
<code><em>name</em></code> must be a valid variable name that may or may not already exist. The
type of <code><em>expression</em></code> must match that of <code><em>name</em></code>: that is, all numeric types can 
be assigned to each other but strings can only be assigned to strings.
<h4>Errors</h4>
-   If <code><em>name</em></code> and <code><em>expression</em></code> are not of matching types: <code>Type mismatch</code>.


LINE statement
LINE [ [STEP] (x0, y0)] - [STEP] (x1, y1) [, [attr] [, [B [F]] [, pattern]]]
--------------
Draws a line or a box in graphics mode. If B is not specified, a line is drawn
from (<code><em>x0</em></code>, <code><em>y0</em></code>) to (<code><em>x1</em></code>, <code><em>y1</em></code>), endpoints inclusive. If B is specified, a
rectangle is drawn with sides parallel to the screen and two opposing corners 
specified by (<code><em>x0</em></code>, <code><em>y0</em></code>) and (<code><em>x1</em></code>, <code><em>y1</em></code>). If the starting point is not given,
the current graphics position is used as a staring point.  If STEP is 
specified, <code><em>x0</em></code>,<code><em>y0</em></code> is an offset from the current position and <code><em>x1</em></code>,<code><em>y1</em></code> is an
offset from <code><em>x0</em></code>,<code><em>y0</em></code>.
LINE moves the current graphics position to the last given endpoint. 
If F is specified with B, the rectangle is filled with the specified attribute. 
F and B may be separated by zero or more spaces. 
'attr' must be a numeric expression between 0 and 255, inclusive, which 
    specifies the colour attribute of the line. If it is not given, the current 
    attribute is used. 
If 'pattern' is specified, it must be a numeric expression between -32768 
    and 32767, inclusive. This is interpreted as a 16-bit binary pattern mask 
    applied to consecutive pixels in the line: a 1 bit indicates a pixel 
    plotted; a 0 bit indicates a pixel left untouched. The pattern starts at 
    the most significant bit, which is applied to the topmost endpoint. If a 
    box is drawn, the pattern is applied in the following counter-intuitive 
    sequence: (x1, y1)-(x0, y1), (x1, y0)-(x0, y0), then (x1, y0)-(x1, y1), 
    (x0, y0)-(x0, y1) if y0<y1 and y0,y1 reversed if y1<y0. When drawing a 
    filled box, LINE ignores the pattern.
<h4>Notes</h4>
-   If a coordinate is outside the screen boundary, it is replaced with -1 (if
    less than 0) or the screen dimension (if larger than the screen dimension).
<h4>Errors</h4>
-   If LINE ends in a comma and it is the first or third, <code>Missing operand</code> is
    raised. If it is the second, <code>Syntax error</code> .
-   If any of the coordinates is not in <code>[-32768&mdash;32767]</code>, <code>Overflow</code> .
-   If any of the parameters has a string value: <code>Type mismatch</code>.


LINE INPUT statement
LINE INPUT [;] [prompt_literal {;|,}] string_name
--------------------
Displays the prompt given in 'prompt_literal' and reads user input from the 
keyboard, storing it into the variable 'string_name'. All input is read until
<code><b>Enter</b></code> is pressed; the first 255 characters are stored. If the ; is given 
right after LINE INPUT, the <code><b>Enter</b></code> ending user input is not echoed to the 
screen. 
'prompt_literal' must be a string literal. It makes no difference whether it is
followed by a comma or a semicolon.
'string_name' must be a valid string variable name or array element.
<h4>Notes</h4>
-   If user input is interrupted by <code><b>Ctrl</b></code>+<code><b>Break</b></code>, CONT will re-execute the LINE 
    INPUT statement.
-   Unlike INPUT, LINE INPUT does not end the prompt with a question mark (?).


LINE INPUT# statement
LINE INPUT # file_num, string_name
---------------------
Reads string or numeric variables from a text file, device, or the FIELD buffer
of a random access file. All input is read until <code><b>Enter</b></code> is pressed; the first 
255 characters are stored. <code><em>file_num</em></code> must be the number of a file open in 
INPUT mode or a device or random-access file open in <code>RANDOM</code> mode. 
'string_name' must be a valid string variable name or array element.
<h4>Notes</h4>
-   The # is mandatory. There may or may not be whitespace between INPUT and #.        
-   Input is only terminated by a <CR>.
-   If <code><em>file_num</em></code> is open to KYBD:, INPUT# reads from the keyboard until a
    return or comma is encountered (as in a file). Arrow keys and delete are
    passed as their control characters (NOT scancodes!) preceded by CHR$(&HFF).
<h4>Errors</h4>
-   If input is requested after the end of a text file has been reached or an
    EOF char has been encountered: INPUT PAST END.
-   If the last character of the field buffer is read: <code>Field overflow</code>.
-   If <code><em>file_num</em></code> is not an open file: <code>Bad file number</code>.
-   If <code><em>file_num</em></code> is less than zero: <code>Illegal function call</code>.
-   If <code><em>file_num</em></code> is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
-   If <code><em>file_num</em></code> is not open for INPUT or <code>RANDOM</code>: <code>Bad file mode</code>.
-   If <code><em>file_num</em></code> is a string: <code>Type mismatch</code>.


LIST statement
LIST [ [line_number_0 | . ] - [line_number_1 | .] ] [, file_name]
LIST [line_number_0 | .] [, file_name]
--------------
Prints the program to the screen, starting with 'line_number_0' up to and 
including 'line_number_1', which must be line numbers in the range [0, 65529]
or a . to indicate the last line edited. The line numbers do not need to exist;
they specify a range. If the range is empty, nothing is printed.
<code><em>file_name</em></code> is a valid file name. This file will be created; if it already 
exists, it will be overwritten.
Also stops program execution and returns to interactive mode. Any further 
statements on a line after LIST will be ignored both in a program and in direct
mode. 
<h4>Errors</h4>
-   If a line number is greater than 65529, <code>Syntax error</code> .
-   If <code><em>file_name</em></code> has a numeric value, <code>Type mismatch</code> .
-   If <code><em>file_name</em></code> ends in a colon but is not a device name or drive letter,
    <code>Bad file number</code> .
    

LLIST statement
LLIST [ [line_number_0|.] - [line_number_1|.] ] 
LLIST [line_number_0|.] 
---------------
Prints the program to LPT1:, starting with 'line_number_0' up to and 
including 'line_number_1', which must be line numbers in the range [0, 65529]
or a . to indicate the last line edited. The line numbers do not need to exist;
they specify a range. If the range is empty, nothing is printed.
Also stops program execution and returns to interactive mode.
<h4>Errors</h4>
-   If a line number is greater than 65529, <code>Syntax error</code> .


LOAD statement
LOAD file_name [, R]
--------------
Loads the program stored in file <code><em>file_name</em></code> into memory.
<code><em>file_name</em></code> must be the name of an existing program file stored in ASCII, 
bytecode or protected format. If ,R is specified, runs the file after loading.
LOAD,R keeps all data files open. Existing variables will be 
cleared and any program in memory will be erased. LOAD implies a CLEAR.
<h4>Notes</h4>
-   If <code><em>file_name</em></code> does not include an extension, .BAS is implied. To load a 
    file without extension, end the filename with a dot. LOAD will first try an 
    all-caps 8.3 version of the name. The search will then continue 
    to match the first 8.3 filename (in lexicographic order) whose uppercase
    version matches that name. 
-   On Windows, the matching 8.3 filename can be a Windows short filename or 
    a long file name which happens to be in 8.3 format (e.g. including spaces).
-   On Unix, it is not possible to load a program with a filename longer than 
    8.3 or ending in a dot.
<h4>Errors</h4>
-   If <code><em>file_name</em></code> cannot be found: <code>File not found</code>.
-   If a loaded ASCII file contains lines without line numbers:
    DIRECT STATEMENT IN FILE.


LOC function
location = LOC(file_num)
------------
Returns the current location in the file opened under number <code><em>file_num</em></code>.
<code><em>file_num</em></code> is a numeric expression in the range <code>[0&mdash;255]</code>. 
If the file is opened for INPUT, OUTPUT or APPEND, LOC returns the number
of 128-byte blocks read or written since opening the file. 
If the file is opened for <code>RANDOM</code>, LOC returns the record number last read or
written. 
If the file is opened to a COM device, LOC returns the number of characters
in the input buffer, with a maximum of 255. 
If the file is opened to KYBD:, LOC returns 0.
<h4>Notes</h4>
-   <code><em>file_num</em></code> must not be preceded by a #.
-   On OUTPUT or APPEND mode, before any writes LOC returns 0. After the 128th 
    character is written, LOC returns 1.
-   In INPUT mode, before any reads LOC returns 1. After the *129th* character
    is read, LOC returns 2. 
<h4>Errors</h4>
-   If <code><em>file_num</em></code> is not an open file: <code>Bad file number</code>.
-   If <code><em>file_num</em></code> is open for output to a device: <code>Bad file mode</code>.
-   If <code><em>file_num</em></code> is not in <code>[0&mdash;255]</code>: <code>Illegal function call</code>.
-   If <code><em>file_num</em></code> is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
-   If <code><em>file_num</em></code> is a string: <code>Type mismatch</code>.


LOCATE statement
LOCATE [row] [, [col] [, [cursor_visible] [, [start_line] [, [stop_line] [,] ] ] 
----------------
Positions the cursor at 'row', 'col' on the screen and changes the cursor.
'cursor_visible' may be 0 or 1 and is ignored. The cursor shape is adjusted 
within a character cell to start from 'start_line' and end on 'end_line' where 
'start_line' and 'end_line' are in [0,31]. If 'start_line' or 'end_line' is 
greater than the character cell height (15), substitute 15. 
Cursor shape and visibility options have no effect in graphics mode. 
<h4>Notes</h4>
-   In GW-BASIC, the cursor shape option calls DOS INT 10h;01. What happens
    to the cursor is then determined by the video card; the result is
    fairly illogical. PC-BASIC does not implement this quirk.
-   In GW-BASIC, cursor shape is preserved after changing to INSERT mode and 
    back; the INSERT cursor is different from the usual half-block. 
    In PC-BASIC, INSERT mode resets the cursor shape to default.
-   According to GW-BASIC documentation, if 'cursor_visible' is 0, it makes 
    the cursor invisible; if it is 1, makes the cursor visible. This appears
    in fact not to happen. 
-   Locate accepts a 5th comma at the end, which is ignored.    
<h4>Errors</h4>
-   If 'row' is outside the current view area: <code>Illegal function call</code>.
-   If 'col' is greater than the current width: <code>Illegal function call</code>.
-   If 'cursor_visible' is not in [0, 1] (<code>[0&mdash;255]</code> on Tandy/PCjr),
    raises <code>Illegal function call</code>.
-   If any parameter is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
-   If any parameter is a string: <code>Type mismatch</code>.


LOCK statement
LOCK [#] file_number [, record_0 ]
LOCK [#] file_number, [record_0] TO record_1
--------------
Locks a file or part of a file against access by other users. On a <code>RANDOM</code> file,
<code><em>file_number</em></code> is a numeric expression in the range <code>[0&mdash;255]</code>.
If specified, 'record_0' is the first record locked and 'record_1' is the last 
record locked. On any other kind of file 'record_0' and 'record_1' have no 
effect. If 'record_0' is not specified, it is assumed to be 1. If no records 
are specified, the whole file is locked.
<h4>Notes</h4>
-   In GW-BASIC under MS-DOS, the LOCK command required SHARE.EXE to be loaded.
    The maximum number of locks is specified in the SHARE command. If SHARE has
    not been activated or all locks are used, LOCK raises PERMISSION DENIED.
    PC-BASIC behaves as if SHARE has been activated with unlimited locks.
-   If <code><em>file_number</em></code> is open for <code>RANDOM</code>, LOCK and UNLOCK statements must match
    in terms of 'record_0' and 'record_1'. An non-matching UNLOCK will raise 
    PERMISSION DENIED.    
<h4>Errors</h4>
-   Attempting to LOCK (part of) a file already locked raises PERMISSION DENIED.
-   If 'record_0' or 'record_1' is not in [1, 2^25-2]: <code>Bad record number</code>.
-   If <code><em>file_num</em></code> is not an open file: <code>Bad file number</code>.
-   If <code><em>file_num</em></code> is not in <code>[0&mdash;255]</code>: <code>Illegal function call</code>.
-   If <code><em>file_num</em></code> is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
-   If any parameter is a string: <code>Type mismatch</code>.
    

LOF function
length = LOF(file_num)
------------
Returns the number of bytes in the file open under <code><em>file_num</em></code>
<code><em>file_num</em></code> is a numeric expression in the range <code>[0&mdash;255]</code>. 
<h4>Notes</h4>
-   If <code><em>file_num</em></code> is open to a COM: device, LOF returns the number of bytes
    free in the input buffer.
<h4>Errors</h4>
-   If <code><em>file_num</em></code> is not an open file: <code>Bad file number</code>.
-   If <code><em>file_num</em></code> is open for output to a device: <code>Bad file mode</code>.
-   If <code><em>file_num</em></code> is not in <code>[0&mdash;255]</code>: <code>Illegal function call</code>.
-   If <code><em>file_num</em></code> is a string: <code>Type mismatch</code>.
-   If <code><em>file_num</em></code> is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.


LOG function
y = LOG(x)
------------
Returns the natural logarithm of <code><em>x</em></code>.
<code><em>x</em></code> is a numeric expression greater than zero.
<h4>Notes</h4>
-   Unless BASIC is run with the --double option, LOG(x) returns a single-
    precision value.
-   LOG(x) can differ from GW-BASIC by 1 in the least significant digit.
<h4>Errors</h4>
-   If <code><em>x</em></code> is a string: <code>Type mismatch</code>.
-   If <code><em>x</em></code> is zero or less: <code>Illegal function call</code>.


LPOS function
position = LPOS(printer_number)
-------------
Returns the column position for a printer. 
'printer_number' is a numeric expression in the range [0,3]. If it is 0
or 1, the position for LPT1 is returned. If it is 2, LPT2; 3, LPT3.
<h4>Notes</h4>
-   In GW-BASIC, when entering interactive mode, LPT1 (but not other printers) 
    is flushed and its position is reset to 1. This is not implemented in 
    PC-BASIC 3.23.
<h4>Errors</h4>
-   If 'printer_number' is not in [0,3]: <code>Illegal function call</code>.
-   If 'printer_number' is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
-   If 'printer_number' is a string: <code>Type mismatch</code>.


LPRINT statement
----------------
See PRINT.


LSET and RSET statements
{L|R}SET string_name = expression
--------------
Assigns a value to a FIELD variable such that it overwrites the FIELD record.
With LSET, the value will be left-justified if it is shorter than the length of
the FIELD variable. With RSET, it will be right-justified.
'string_name' is a valid name of a string variable.
<code><em>expression</em></code> is a string expression.
<h4>Notes</h4>
-   If 'string_name' is not a FIELD variable, the value is justified into the 
    existing string, which retains its length.
-   If <code><em>expression</em></code> has a value that is longer than the length of the variable,
    it is truncated at the back at the length of the variable.
-   If LET is used on a FIELD variable instead of L|RSET, the variable is 
    detached from the field and becomes a normal string variable.
<h4>Errors</h4>
-   If 'string_name' is not a string variable, <code>Type mismatch</code> .
-   If <code><em>expression</em></code> does not have a string value, <code>Type mismatch</code> .


<code>MERGE</code> statement
<code>MERGE</code> file_name
---------------
Overlays the lines of program <code><em>file_name</em></code> into the existing program. The loaded
lines overwrite existing lines if they have the same line number. <code><em>file_name</em></code> 
must be the name of an existing program file stored in ASCII format only. 
<h4>Notes</h4>
-   If <code><em>file_name</em></code> does not include an extension, <code>MERGE</code> will try the name 
    specified, then an all-caps version, then an all-caps version with a .BAS 
    extension.
<h4>Errors</h4>
-   If <code><em>file_name</em></code> cannot be found: <code>File not found</code>.
-   If <code><em>file_name</em></code> was not saved as ASCII: <code>Bad file mode</code>.
-   If a loaded ASCII file contains lines without line numbers:
    DIRECT STATEMENT IN FILE.
    

MID$ function
substring = MID$(string, position [, length])
-------------
Returns a substring of 'string' starting at 'position', counting from 1. The 
substring has length 'length' if specified, defaulting to 1.
'string' is a string expression.
'position' is a numeric expression between 1 and the string length.
'length' is a numeric expression between 0 and 255, inclusive.
<h4>Errors</h4>
-   If 'string' has a number value or 'position' or 'length' have string values,
    raises <code>Type mismatch</code>.
-   If 'position' is not in [1,255]: <code>Illegal function call</code>.
-   If 'length' is not in <code>[0&mdash;255]</code>: <code>Illegal function call</code>.
-   If 'position' or 'length' are not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.


MID$ statement
MID$(string_name, position [, length]) = substring
--------------
Replaces part of 'string_name' with 'substring'.
'string_name' is a valid string variable name.
'position' is a numeric expression between 1 and the string length.
'length' is a numeric expression between 0 and 255, inclusive.
<h4>Notes</h4>
-   If 'substring' is longer than 'length', only the first 'length' characters
    are used.
-   If 'substring' is shorter than 'length', only LEN(substring) characters
    are replaced.
<h4>Errors</h4>
-   If 'position' is greater than the length of 'string_name',
    raises <code>Illegal function call</code>, except if 'length' is specified as 0.
-   If 'position' is not in [1,255]: <code>Illegal function call</code>.
-   If 'length' is not in <code>[0&mdash;255]</code>: <code>Illegal function call</code>.
-   If 'position' or 'length' are not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.


MKDIR statement
MKDIR path
---------------
Creates a directory. 'path' is a string expression that specifies the 
path of the new directory.  
<h4>Notes</h4>
-   'path' will be modified into all-uppercase 8.3 format.
<h4>Errors</h4>
-   If 'path' is not a string: <code>Type mismatch</code>.
-   If the parent directory of 'path' does not exist: <code>Path not found</code>.
-   If the pathname already exists: PATH/FILE ACCESS ERROR.
-   If the user has no write permission: PERMISSION DENIED.


MKD$ function
bytes = MKD$(double)
-------------
Returns the internal 8-byte Microsoft Binary Format representation of a double-
precision number.
<h4>Errors</h4>
-   If 'double' is a string: <code>Type mismatch</code>.


MKI$ function
bytes = MKI$(int)
-------------
Returns the internal 2-byte little-endian representation of an integer.
<h4>Errors</h4>
-   If 'int' is a string: <code>Type mismatch</code>.
-   If 'int' is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.


MKS$ function
bytes = MKS$(single)
-------------
Returns the internal 4-byte Microsoft Binary Format representation of a single-
precision number.
<h4>Errors</h4>
-   If 'single' is a string: <code>Type mismatch</code>.


MOTOR statement
MOTOR [num]
---------------
Does nothing. <code><em>num</em></code> is a numeric expression between 0 and 255, inclusive.
<h4>Notes</h4>
-   This statement does nothing in GW-BASIC. Presumably, it is left over from a
    statement in older versions of MS Basic that would drive the cassette tape 
    player.
<h4>Errors</h4>
-   If <code><em>num</em></code> is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
-   If <code><em>num</em></code> is not in <code>[0&mdash;255]</code>: <code>Illegal function call</code>.
-   If <code><em>num</em></code> has a string value: <code>Type mismatch</code>.


NAME statement
NAME old_name AS new_name
--------------
Renames the file 'old_name' into 'new_name'
'old_name' and 'new_name' are string expressions.
<h4>Notes</h4>
-   'new_name' will be modified into all-uppercase 8.3 format.
<h4>Errors</h4>
-   If 'old_name' or 'new_name' have number values: <code>Type mismatch</code>.
-   If 'old_name' does not exist: <code>File not found</code>.
-   If 'old_name' is open: FILE ALREADY OPEN.
-   If 'new_name' exists: FILE ALREADY EXISTS.


NEW statement
NEW 
-------------
Deletes the program in memory, executes CLEAR and RESTORE and returns to 
interactive mode.


NEXT statement
NEXT [var_0 [, var_1 [, ...] ] ]
--------------
Iterates a FOR--NEXT loop: increments the loop variable and jumps to the FOR 
statement. If no variables are specified, next matches the most recent FOR 
statement. Several nested NEXT statements can be consolidated into one by 
using the variable list. If one or more variables are specified, their order 
must match the order of earlier FOR statements.  
<h4>Errors</h4>
-   If no FOR statement is found to match the NEXT statement and variables, 
    NEXT WITHOUT FOR .
-   If 'var_0', ... are string names, NEXT WITHOUT FOR .


NOISE statement                                    [pcjr and tandy syntax only]
NOISE source, volume, duration
-------------
PCJR and TANDY:
    Generates various kinds of noise.
    'source' is a numeric expression in [0, 7]. 
    It indicates the type of noise:
    source  type            max frequency (Hz)
    0       periodic        6991
    1       periodic        3495
    2       periodic        1747
    3       periodic        last tone played on tone voice channel 2
    0       white noise     6991
    1       white noise     3495
    2       white noise     1747
    3       white noise     last tone played on tone voice channel 2
    'volume' is a numeric expression in [0,15].
    'duration' is a numeric expression.
    Volume and duration are determined in the same way as for the SOUND 
    statement; see there.
<h4>Errors</h4>
-   IF SOUND ON has not been executed: <code>Illegal function call</code>.
-   If 'duration' is not in [-65535, 65535]: <code>Illegal function call</code>.
-   If 'volume' is not in [0, 15]: <code>Illegal function call</code>.
-   If 'voice' is not in [0, 2]: <code>Illegal function call</code>.


OCT$ function
octal = OCT$(x)
-------------
Returns a string with the octal representation of <code><em>x</em></code>. <code><em>x</em></code> must be a 
numeric expression between -32768 and 65535, inclusive. Values for 
negative <code><em>x</em></code> are shown as two's-complement. 
<h4>Errors</h4>
-   If <code><em>x</em></code> is not in <code>[-32768&mdash;65535]</code>, <code>Overflow</code> .
-   If <code><em>x</em></code> has a string value, <code>Type mismatch</code> .


ON statement (switched jump)
ON n {GOTO|<code>GOSUB</code>} line_number_0 [, line_number_1 [, ...] ]
------------
Jumps to the <code><em>n</em></code>th line number specified in the list. If <code><em>n</em></code> is 0 or greater 
than the number of line_numbers in the list, no jump is performed. <code><em>n</em></code> must 
be a numeric expression in the range <code>[0&mdash;255]</code>. IF GOTO is specified, 
the jump is unconditional; if <code>GOSUB</code> is specified, jumps to a subroutine.
<h4>Errors</h4>
-   If <code><em>n</em></code> is a string: <code>Type mismatch</code>.
-   If <code><em>n</em></code> is not in <code>[0&mdash;255]</code>: <code>Illegal function call</code>.
-   If <code><em>n</em></code> is not in <code>[-32768&mdash;32767]</code>, <code>Overflow</code> .


ON statement (event trapping)
ON { COM(n) | KEY(n) | STRIG(n) | PEN | PLAY(n) | TIMER (x) } <code>GOSUB</code> line_number
------------
Defines an event trapping subroutine. 
The type of event is given by one of the following keywords:
COM(n)      <code><em>n</em></code> in [1,2] is the COM1 or COM2 port. The event is triggered 
            if data is present in the input buffer of the port.
KEY(n)      <code><em>n</em></code> is the key number: 1-10 are <F1>-<F10>, 11: <UP>, 12: <LEFT>, 
            13: <RIGHT>, 14: <DOWN>. 15-20 are user-definable. The event is
            triggered if the key is pressed.
STRIG(n)    <code><em>n</em></code> in [0,2,4,6] refer to the two fire triggers on two joysticks. 
            They event is triggered if the button is pressed.
PEN         In GW-BASIC, the event is triggered if the light pen is on the 
            screen. In PC-BASIC, the event is triggered if the left mouse 
            button is pressed. 
PLAY (n)    The event is triggered if there are exactly <code><em>n</em></code> notes left on the
            music background queue. <code><em>n</em></code> is a numeric expression in [1,32]    
TIMER (x)   The event is triggered every <code><em>x</em></code> seconds after the TIMER ON 
            statement. <code><em>x</em></code> is a numeric expression in [1, 86400].
Before event trapping is active, the event needs to be enabled using the event
statements: COM(n) ON | KEY(n) ON | STRIG(n) ON | PEN ON | PLAY ON | TIMER ON.
Events are not trapped in interactive mode.
<h4>Errors</h4>
-   If <code><em>n</em></code> or <code><em>x</em></code> is a string: <code>Type mismatch</code>.
-   If <code><em>n</em></code> or <code><em>x</em></code> is outside the specified range: <code>Illegal function call</code>.
-   If <code><em>n</em></code> is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.


ON ERROR statement 
ON ERROR GOTO line_number
------------------
Defines an error handler. After this statement, any error causes the handler
routine to be called; no message is printed and execution is not stopped. The
handler routine is ended by a RESUME statement.
While in an error handling routine, events are paused and error trapping is
disabled. After the RESUME statement, events are picked up in the following 
order: KEY, TIMER, PLAY - the order of the others is unknown.
Error trapping remains active in interactive mode.
<h4>Notes</h4>
-   If <code><em>line_number</em></code> is 0, turns off error trapping.
<h4>Errors</h4>
-   If <code><em>line_number</em></code> does not exist: <code>Undefined line number</code>.


OPEN statement
OPEN mode_char, [#] file_num, file_name [, rec_len]
OPEN file_name 
    [ FOR { INPUT | OUTPUT | APPEND | RANDOM } ] 
    [ ACCESS { READ | WRITE | READ WRITE } ] 
    [ SHARED | LOCK { READ | WRITE | READ WRITE } ] 
    AS [#] file_num [ LEN = rec_len ]
--------------
Opens a data file or device.
<code><em>file_name</em></code> is a string expression: the name of the file or device.
<code><em>file_num</em></code> is a numeric expression in [1,3].
<code><em>rec_len</em></code> is a numeric expression in [1,128]: the record length.
In the first syntax only:
-   'mode_char' is a string expression of which the first character is
    one of "I" for INPUT, "O" for OUTPUT, "A" for APPEND, "R" for <code>RANDOM</code>.
The FOR modes:
-   INPUT opens a text file for reading and positions the file pointer at the 
    start.
-   OUTPUT truncates a text file at the start and opens it for writing. Any 
    data previously present in the file will be deleted.
-   APPEND opens a text file for writing at the end of any existing data.
-   <code>RANDOM</code> opens a file for random access; the file is divided in records of
    length <code><em>rec_len</em></code>. If LEN is not specified, the record length defaults to 
    128. The file contents can be accessed using GET and PUT of the FIELD
    buffer; the FIELD buffer can be accessed through FIELD variables or through
    PRINT# and INPUT# statements. 
-   If no FOR mode / mode_char is specified, the file is opened for <code>RANDOM</code>.
The ACCESS modes:
-   If no ACCESS mode is specified, the default is READ WRITE for <code>RANDOM</code>,
    READ for INPUT, WRITE for OUTPUT, READ WRITE for APPEND.
-   If both FOR and ACCESS are specified, any ACCESS mode is allowed for
    <code>RANDOM</code> but for the other modes the access must match as above.
The SHARED/LOCK modes:    
-   If not specified, the file is locked exclusively for use by the 
    current BASIC process. Inside this process, a file may be opened multiple
    times for INPUT or <code>RANDOM</code> but only once for OUTPUT or APPEND, as long as it
    is again opened in default mode. It may not be opened in SHARED or any LOCK 
    modes.
-   If specified as SHARED, LOCK READ, LOCK WRITE or LOCK READ WRITE, whether 
    two OPEN statements may access the same file depends on one's LOCK status
    and the other's ACCESS status and vice versa. Assuming the following:
        OPEN "file" ACCESS acc_1 lock_1 AS 1
        OPEN "file" ACCESS acc_2 lock_2 AS 2
    The following combinations are allowed, and vice versa:
               acc_2 >      READ    WRITE    READ WRITE
        lock_1 
        SHARED              yes     yes     yes      
        LOCK READ           no      yes     no
        LOCK WRITE          yes     no      no
        LOCK READ WRITE     no      no      no
In GW-BASIC under MS-DOS with SHARE active, these locks should be functioning
across a network as well as inside a single BASIC process. In PC-BASIC 3.23,  
the locks are only implemented internally; whether other processes may access 
the file will depend on the host OS.
SERIAL PORT (COM1) ACCESS:
-   When opening a COM port, additional expressions may be include following the
    colon of the device name. These specify parameters for the serial
    connection. This string has the form
    "COMn:[speed][,parity][,data][,stop][,RS][,CS[n]][,DS[n]][,CD[n]][,LF][,PE]"
    The meaning of the parameters is:
    speed   baud (bps) rate for the connection. 'speed' must be one of
            {75, 110, 150, 300, 600, 1200, 1800, 2400, 4800, 9600}.
            Default is 300.
    parity  parity bit convention. 'parity' must be one of [S, M, O, E, N]. 
            S   SPACE   Parity bit always set to 0.
            M   MARK    Parity bit always set to 1.
            O   ODD     Parity bit set so that character parity is odd.
            E   EVEN    Parity bit set so that character parity is even.
            N   NONE    No parity bit transmitted or received.
            Default is E.
    data    data bits per byte. 'data' must be one of {4, 5, 6, 7, 8}. 
            A byte consists of the data bits plus parity bit, if
            any. Byte size must be in the range [5...8]: if 'data' is 4, 
            'parity' must not be N; if 'data' is 8, 'parity' must be N.
            Default is 7.
    stop    The number of stop bits. <code><em>stop</em></code> must be 1 or 2.
            Default is 2 if speed is 75 or 110; 1 otherwise.
    LF      if specified, send a line feed after each return.
    The following GW-BASIC specifications are ignored by PC-BASIC:
    RS      if specified, suppress Request To Send.
    CS[n]   set Clear To Send timeout to n milliseconds. 
            If n is not given, set timeout to 0. 
            Default is CS0 if RS is set; CS1000 otherwise.
    DS[n]   set Data Set Ready timeout to n milliseconds. 
            If n is not given, set timeout to 0. 
            Default is DS1000.
    CD[n]   set Carrier Detect timeout to n milliseconds. 
            If n is not given, set timeout to 0. 
            Default is CD0.
    PE      enable parity checking.
-   If a COM port is opened for <code>RANDOM</code>, access is
    byte-for-byte rather than through FIELD records; PRINT# and INPUT# access 
    the port directly. <code><em>rec_len</em></code> sets the number of bytes read by the GET and
    PUT statements.
<h4>Notes</h4>
-   For INPUT, OUTPUT and APPEND modes, LEN may be specified but is ignored.
-   If i/o is attempted contravening the FOR mode specified, the PRINT or INPUT
    statement will raise <code>Bad file mode</code>.
-   If <code>RANDOM</code> i/o is attempted contravening the ACCESS mode specified, the 
    PUT or GET statement will raise PATH/FILE ACCESS ERROR.
-   The # is optional and has no effect.    
<h4>Errors</h4>
-   If <code><em>file_name</em></code> is empty or a non-existent device: <code>Bad file number</code>.
-   If FOR APPEND ACCESS WRITE is specified: PATH/FILE ACCESS ERROR.
-   If FOR and ACCESS mismatch in other ways: <code>Syntax error</code>.
-   If the COM: file_name parameters do not follow the specification,
    <code>Bad file name</code> .
-   If a file is already open for OUTPUT or APPEND: FILE ALREADY OPEN.
    This is not the case for devices.
-   IF <code><em>rec_len</em></code> or <code><em>file_num</em></code> have string values: <code>Type mismatch</code>.
-   If <code><em>file_name</em></code> or 'mode_char' have number values: <code>Type mismatch</code>.
-   If <code><em>file_num</em></code> is not in [1,3]: <code>Bad file number</code>.
-   If <code><em>file_num</em></code> is not in <code>[0&mdash;255]</code>: <code>Illegal function call</code>.
-   If <code><em>file_num</em></code> is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
-   If <code><em>rec_len</em></code> is not in [1,128]: <code>Illegal function call</code>.
-   If <code><em>rec_len</em></code> is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
-   If 'mode_char' shorter than 1 or the first character is not in  
    ["I", "O", "A", "R"]: <code>Bad file mode</code>.
    

OPTION BASE statement
OPTION BASE n
---------------------
Sets the starting index of all arrays to <code><em>n</em></code>, where <code><em>n</em></code> must be a literal digit
 0 or 1. Note that expressions are not allowed for n.
<h4>Notes</h4>
-   If OPTION BASE is not called, the first array DIM defaults to starting 
    index 0.
<h4>Errors</h4>
-   If <code><em>n</em></code> is not a digit 0 or 1, <code>Syntax error</code> .
-   If OPTION BASE 1 is called but any array has already been DIMmed or indexed
    before calling OPTION BASE 
    with a different starting index, <code>Duplicate definition</code> .
-   If OPTION BASE is called more than once with different starting index,
    <code>Duplicate definition</code> .


OUT statement
OUT port, value
-------------
Sends a byte to an emulated machine port. 
<code><em>port</em></code> is a numeric expression in [-32768,65535].
<code><em>value</em></code> is a numeric expression in <code>[0&mdash;255]</code>.
The following ports are emulated:
    port    effect
    &h201   resets the game port (joystick port)
    &h3C5   sets the write mask for SCREEN 7,8,9 colour planes; 
            bitmask = 2 ^ <code><em>value</em></code>.
    &h3CF   sets the read colour plane to <code><em>value</em></code>.
    &h3D8   if <code><em>value</em></code> = &h1A, enable composite colorburst (cga, tandy, pcjr)
            if <code><em>value</em></code> = &h1E, disable composite colorburst (cga, tandy, pcjr)
Does nothing otherwise.
<h4>Notes</h4>
-   Only a limited number of machine ports are emulated.
-   In GW-BASIC, the sequence needed to set the colour plane mask is:
        OUT &h3C4, 2        
        OUT &h3C5, 2 ^ plane
    The sequence needed to set the colour plane is:
        OUT &h3CE, 4     
        OUT &h3CF, plane 
    The initial OUT statements currently have no effect in PC-BASIC 3.23.    
<h4>Errors</h4>
-   If <code><em>port</em></code> is not in <code>[-32768&mdash;65535]</code>: <code>Overflow</code>.
-   If <code><em>value</em></code> is not in [-32768, 32768]: <code>Overflow</code>.
-   If <code><em>value</em></code> is not in <code>[0&mdash;255]</code>: <code>Illegal function call</code>.
-   If <code><em>port</em></code> or <code><em>value</em></code> are strings: <code>Type mismatch</code>.


PAINT statement
PAINT [STEP] (x, y) [, attrib [, border [, background ] ] ]
---------------
Flood-fills the screen with a colour or pattern.
<code><em>x</em></code>, <code><em>y</em></code> are numeric expressions in the range <code>[-32768&mdash;32767]</code> which give
the seed point for the flood fill. If STEP is specified, <code><em>x</em></code> <code><em>y</em></code> are offsets 
from the current position. If the seed point is outside the visible screen 
area, no flood fill is performed.
'attrib' is an expression that specifies the fill attribute or pattern. If not 
specified, the current foreground attribute is used. 
If 'attrib' has a number value, it must be in <code>[0&mdash;255]</code>; it specifies the colour 
attribute used to fill. 
If 'attrib' has a string value, it specifies a tile pattern (see below).
<code><em>border</em></code> is a numeric expression in <code>[0&mdash;255]</code>. It specifies the attribute
of the fill boundary (see below).
<code><em>background</em></code> is a string expression that represents a background tile 
pattern to ignore when determining boundaries (see below).
TILE PATTERNS
    A tile pattern can be specified by a string of up to 255 characters. The 
    interpretation of the string depends on the number of bits per pixel in 
    the current screen mode.
    SCREEN 2:
        For a one-bit-per-pixel mode (as in SCREEN 2), here is an example:
        <pre>
                  76543210    value
                  *.......    CHR$(&h80)        
                  .*......    CHR$(&h40)        
                  ..*.....    CHR$(&h20)        
                  ...*....    CHR$(&h10)        
                  ....*...    CHR$(&h08)
                  .....*..    CHR$(&h04)
                  ......*.    CHR$(&h02)
        </pre>
    SCREEN 7, 8, 9:
        The tile pattern is always 8 pixels wide. The first character in the 
        pattern string contains the first bit of each of these 8 pixels, the 
        second character contains the second bits, etc. 
        For example, in a 2-bits-per-pixel mode, the pattern can have many
        colours. However, the same size pattern as above in attribute &h03 is:
        <pre>
            bit   76543210    value
            0     *.......    CHR$(&h80)        
            1     *.......    CHR$(&h80)        
            0     .*......    CHR$(&h40)        
            1     .*......    CHR$(&h40)        
            0     ..*.....    CHR$(&h20)        
            1     ..*.....    CHR$(&h20)        
            0     ...*....    CHR$(&h10)        
            1     ...*....    CHR$(&h10)        
            0     ....*...    CHR$(&h08)
            1     ....*...    CHR$(&h08)
            0     .....*..    CHR$(&h04)
            1     .....*..    CHR$(&h04)
            0     ......*.    CHR$(&h02)    
            1     ......*.    CHR$(&h02)    
        </pre>
        If the pattern string is truncated before all bits of the last line 
        have been defined, the remaining bits will be zero.
    SCREEN 1, 3, 4, 5, 6:
        Each row of the tile pattern represents a screen row. Colours are 
        encoded in consecutive bits - the more bits per pixel, the narrow the
        pattern is. For 2 bits per pixel, the pattern is 4 pixels wide; for 4 
        bits per pixel it is 2 pixels wide. The pattern form above now encodes
        a multicoloured tile:
       <pre>
            3210  76543210    value
            2000  *.......    CHR$(&h80)        
            1000  .*......    CHR$(&h40)        
            0200  ..*.....    CHR$(&h20)        
            0100  ...*....    CHR$(&h10)        
            0020  ....*...    CHR$(&h08)
            0010  .....*..    CHR$(&h04)
            0002  ......*.    CHR$(&h02)
         </pre>
    The tile pattern is locked to the screen; imagine a grid starting at 
    (0,0) and covering the screen. Whenever an area is tile-filled,
    the tiles are put into this grid. In this way, adjacent areas will have
    continuous tiling even if they were filled from different seed points.
BOUNDARIES
    A solid flood fill stops at pixels that have the same attribute as the fill
    or that have the specified border attribute, if specified.
    A tiling flood fill stops at the specified border attribute; if no border
    attribute is specified, it stops at the current foreground attribute.
    A tiling flood fill also stops at scan line intervals that are the same as 
    the tiling pattern for that line, unless a background pattern is specified
    and the interval also equals the background pattern for that line.
<h4>Errors</h4>
-   In SCREENs 7,8,9, if <code><em>background</em></code> equals 'attrib' up to the length of
    'attrib': <code>Illegal function call</code>.
-   If <code><em>background</em></code> has a number value: <code>Illegal function call</code>.
-   If <code><em>border</em></code>,<code><em>x</em></code>, or <code><em>y</em></code> have a string value: <code>Type mismatch</code>.
-   If <code><em>border</em></code> is not in <code>[0&mdash;255]</code>: <code>Illegal function call</code>.
-   If 'attrib' is numeric and not in <code>[0&mdash;255]</code>: <code>Illegal function call</code>.
-   If <code><em>border</em></code>,<code><em>x</em></code>, or <code><em>y</em></code> are not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
-   If 'attrib' is numeric and not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.


PALETTE statement
PALETTE [ attrib, colour ]
-----------------
Assigns a colour to an attribute. All pixels with that attribute will change 
colour immediately.
If no parameters are specified, PALETTE resets to the initial setting.
'attrib' is a numeric expression between 0 and the current palette 
size, less one. 
<code><em>colour</em></code> is a numeric expression between -1 and the maximum number of 
colours for the current screen mode, less one. If <code><em>colour</em></code> equals -1,
the palette remains unchanged.
<h4>Errors</h4>
-   If 'attrib' or <code><em>colour</em></code> are strings: <code>Type mismatch</code>.
-   If 'attrib' or <code><em>colour</em></code> are not in range: <code>Illegal function call</code>
-   If 'attrib' or <code><em>colour</em></code> are not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>


PALETTE USING statement
PALETTE USING int_array_name { ( | [ } start_index { ) | ] }
-----------------------
Assigns new colours to all attributes.
'int_array_name' is the name of an array of integers (I%) that will supply the
new values for the palette. 'start_index' is a numeric expression that 
indicates at which index in the array to start mapping to the palette. If an 
array index equals -1, the matching attribute is left unchanged.
<h4>Errors</h4>
-   If 'int_array_name' has not been dimensioned: <code>Illegal function call</code>.
    The array will not be automatically dimensioned.
-   If 'int_array_name' is not an integer array: <code>Type mismatch</code>.
-   If 'int_array_name' is too short: <code>Illegal function call</code>.
-   If 'start_index' is a string: <code>Type mismatch</code>.
-   If 'start_index' is outside array dimensions: SUBSCRIPT OUT OF RANGE
-   If 'start_index' is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>


PCOPY statement
PCOPY src, dst
---------------
Copies the screen page 'src' to 'dst'. All text and graphics on 'dst' is 
replaced by those of 'src'.
'src' and 'dst' are numeric expressions between 0 and the current video 
mode's number of pages, less one. 
<h4>Errors</h4>
-   If 'src' or 'dst' are string: <code>Type mismatch</code>.
-   If 'src' or 'dst' are out of range: <code>Illegal function call</code>.
-   If 'src' or 'dst' are not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.


PEEK function
value = PEEK(address)
-------------
Returns the value of the memory at the current DEF SEG segment * 16 + <code><em>address</em></code>
<code><em>address</em></code> must be in [-32768, 65536]. Negative values are interpreted as their 
two's complement.
<h4>Notes</h4>
-   The memory is only partly emulated in PC-BASIC 3.23. PEEK can be used to
    access variable and string space (using VARPTR), but not arrays of strings,
    the stored program, or file descriptors. It can also be used to access the
    emulated video memory.
-   Values for particular memory address can be preset on the command line 
    using the --peek option. This can be used for compatibility with old 
    programs. These values will override video or data segment values, if they
    are in those locations.
-   Outside these emulated areas, PEEK returns 0. 
<h4>Errors</h4>
-   If <code><em>address</em></code> is a string: <code>Type mismatch</code>.
-   If <code><em>address</em></code> is not in [-32768, 65536]: <code>Overflow</code>.


PEN statement
PEN { ON | OFF | STOP }
-------------
Controls event trapping and read access of the light pen (in PC-BASIC 3.23,
emulated through the mouse). If ON is specified pen reading and trapping is 
switched on; if OFF, off. STOP suspends event trapping until another PEN ON is
executed. Up to one event can be triggered during suspension, provided that 
event handling was switched on prior to suspension. The event triggered during 
suspension is handled immediately after the next PEN ON statement.


PEN function
x = PEN(mode)
------------
Reads the light pen. What PEN returns depends on 'mode'.
'mode' is a numeric expression in [0, 9]. PEN returns the following:
'mode'  PEN result
  0     Boolean: whether the light pen has been down since last poll.
  1     x coordinate of last pen down position
  2     y coordinate of last pen down position
  3     Boolean: if the pen is currently down
  4     x coordinate of current pen position  
  5     y coordinate of current pen position  
  6     character row coordinate of last pen down position
  7     character column coordinate of last pen down position
  8     character row coordinate of current pen position
  9     character column coordinate of current pen position
<h4>Notes</h4>
-   In PC-BASIC 3.23, for 'pen down' read 'left mouse button pressed'. For 'pen
    position' read 'mouse pointer position'.
<h4>Errors</h4>
-   If 'mode' is a string: <code>Type mismatch</code>.
-   If 'mode' is not in [0, 9]: <code>Illegal function call</code>.
-   If 'mode' is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
    

PLAY statement
PLAY mml_string
PLAY [mml_string_0] [, [mml_string_1] ] [, [mml_string_2] ]]      [tandy, pcjr]
--------------
Plays the tune defined by string expression 'mml_string'. 'mml_string' 
must be a string expression in Music Macro Language (MML). 
MML reference:
Notes:
    { A|B|C|D|E|F|G }[ #|+|- ][n]   Plays the corresponding note, with or + for 
                                    sharp and - for flat. If <code><em>n</em></code> follows, it
                                    indicates duration as in L below.
    Nn  Play note <code><em>n</em></code>, in the range [0, 84] (7 octaves). <code><em>n</em></code> = 0 means rest.                                    
    On  Sets the current octave to <code><em>n</em></code>, in the range [0,6]. Default is 4.
    >   Increases the current octave by 1, with a maximum of 6.   
    <   Decreases the current octave by 1, with a minimum of 0.   
    Pn  Pause for duration <code><em>n</em></code> as in L below.
Duration:
    .   Increase the duration of the preceding note by 1/2 times its normal
        duration. Periods can be repeated to increase duration further.
    Ln  Set the duration of following note. <code><em>n</em></code>=4 is a quarter note, etc.
        <code><em>n</em></code> is in the range [1, 64].
    MN  Normal: 7/8 of the duration is sound, with 1/8 silence. Default mode.
    ML  Legato: full duration is sound.
    MS  Staccato: 3/4 of the duration is sound, with 1/4 silence. 
Tempo:    
    Tn  Sets the tempo to <code><em>n</em></code> L4s per minute. Default is 120.
Background mode (affects SOUND, PLAY and BEEP)
    MB  Turns on background mode; sound commands exit without waiting for the 
        music to finish. The music keeps playing while other commands are 
        executed. There can be up to 16 notes in the background music queue;
        if more notes are played, PLAY will block until there are only 16 left.
    MF  Turns off background mode; sound commands block. Default mode.
Subroutine command:
    Xs      execute substring. 's' is one of the following:
            -   a string variable name followed by semicolon (;)
            -   the result of VARPTR$() on a string variable
Numeric variables <code><em>n</em></code> in the commands above can be:
    -   an integer literal e.g. "100"
    -   a numeric variable name preceded by = and followed by ; e.g. "=name;"
    -   the result of VARPTR$() on a numeric variable, preceded by =.  
TANDY and PCJR:
    The three separate mml strings correspond to the three tone voice channels.
    The notes in these strings are played synchronously.
    Volume control:
        Vn  Set the volume to <code><em>n</em></code>, in the range [0, 15]. On PCjr, if SOUND ON
            has not been executed, this has no effect. On Tandy it does.              
<h4>Errors</h4>
-   If 'mml_string' has a numeric value, <code>Type mismatch</code> .
-   If 'mml_string' has errors in the MML, <code>Illegal function call</code> .
-   If a variable in the mml_string is of incorrect type, <code>Type mismatch</code>.
-   If no mml string is specified: <code>Missing operand</code>.
-   On PCjr, if SOUND ON has not been executed, using the three-voice syntax
    will raise <code>Syntax error</code>. This is not the case on Tandy.


PLAY function
length = PLAY(voice)
-------------
Returns the number of notes in the background music queue.
'voice' is a numeric expression in <code>[0&mdash;255]</code>. 
PCJR and TANDY:
    On PCjr and Tandy, the 'voice' value indicates for which tone voice channel
    the number of notes is to be returned. If 'voice' is not in [0,2], the 
    queue for voice 0 is returned.
OTHERS:
    The 'voice' value has no effect.    
The return value is in [0,16].
<h4>Notes</h4>
-   There are at most 16 notes in the music queue. Some GW-BASIC manuals
    claim there can be up to 32, but in reality PLAY only returns at the
    last 16 notes.
<h4>Errors</h4>
-   If <code><em>dummy</em></code> is a string: <code>Type mismatch</code>.
-   If <code><em>dummy</em></code> is not in <code>[0&mdash;255]</code>: <code>Illegal function call</code>.
-   If <code><em>dummy</em></code> is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.


PMAP function
physical = PMAP(logical, fn)
-------------
Maps between physical and logical coordinates, taking into account the settings
of the last WINDOW statement (but not VIEW!). IN a VIEW port, the coordinates
are considered to be physical coordinates.
The operation depends on 'fn':
'fn'    operation
  0     return physical/viewport x given logical coordinates
  1     return physical/viewport y given logical coordinates
  2     return logical (WINDOW) x given physical coordinates
  3     return logical (WINDOW) y given physical coordinates
<h4>Notes</h4>
-   Initially, in text mode, PMAP returns 0.
-   In GW-BASIC, PMAP behaves anomalously on SCREEN changes, where it sometimes
    returns results as if the last WINDOW setting had persisted. This is not
    implemented in PC-BASIC 3.23. 
<h4>Errors</h4>
-   If a physical coordinate is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
-   If any of the parameters has a string value: <code>Type mismatch</code>.
-   If 'fn' is not in [0,3]: <code>Illegal function call</code>.
-   If 'fn' is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.


POINT function (current coordinate)
coord = POINT(fn)
--------------
Returns a currently active coordinate of the graphics screen. This is usually
the last position at which a pixel has been plotted, the second corner given
in a LINE command, or the centre of the viewport if nothing has been plotted.
'fn' is a numeric expression in [0, 3].
The coordinate returned depends on the value of 'fn':
fn  return value
 0  physical/viewport x coordinate
 1  physical/viewport y coordinate
 2  logical (WINDOW) x coordinate 
 3  logical (WINDOW) y coordinate
<h4>Notes</h4>
-   In SCREEN 0, returns the active coordinate of any previous graphics mode;
    if no graphics mode has been active, returns 0.
<h4>Errors</h4>    
-   If 'fn' has a string value: <code>Type mismatch</code>.
-   If 'fn' is not in [0,3]: <code>Illegal function call</code>.
-   If 'fn' is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.


POINT function (pixel attribute)
attrib = POINT (x, y)
--------------
Returns the attribute of the pixel at logical coordinate <code><em>x</em></code>,<code><em>y</em></code>.
<code><em>x</em></code>, <code><em>y</em></code> are numeric expressions in [-32768, 32768].
<h4>Notes</h4>
-   If <code><em>x</em></code>,<code><em>y</em></code> is outside the screen, returns -1.
<h4>Errors</h4>
-   In SCREEN 0: <code>Illegal function call</code>.
-   If <code><em>x</em></code> or <code><em>y</em></code> has a string value: <code>Type mismatch</code>.
-   If <code><em>x</em></code> or <code><em>y</em></code> or the physical coordinates they translate into are not in
    <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.


POKE statement
POKE address, value
--------------
Sets the value of the memory at the current DEF SEG segment * 16 + <code><em>address</em></code>.
<code><em>address</em></code> is anumeric expression in <code>[-32768&mdash;65535]</code>. Negative values are
interpreted as their two's complement.
<code><em>value</em></code> is a numeric expression in <code>[0&mdash;255]</code>.
<h4>Notes</h4>
-   In GW-BASIC, POKE sets memory location <code><em>address</em></code> to <code><em>value</em></code>. This is not 
    implemented in PC-BASIC 3.23 outside the emulated areas.
-   Currently, only writing to video memory is supported.
<h4>Errors</h4>
-   If <code><em>address</em></code> or <code><em>value</em></code> has a string value: <code>Type mismatch</code>.
-   If <code><em>value</em></code> is not in <code>[0&mdash;255]</code>: <code>Illegal function call</code>.
-   If <code><em>address</em></code> is not in <code>[-32768&mdash;65535]</code>: <code>Overflow</code>.
-   If <code><em>value</em></code> is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.


POS function
pos = POS(dummy)
------------
Returns the current cursor column position, in the range [1, 80].
<code><em>dummy</em></code> is a valid expression of any type; its value has no effect.


PSET and PRESET statements
P[RE]SET [STEP] (x, y) [, attrib]
----------------
Change the attribute of a pixel on the screen at position <code><em>x</em></code>, <code><em>y</em></code>.
If STEP is specified, <code><em>x</em></code>,<code><em>y</em></code> is an offset from the current position.
<code><em>x</em></code>, <code><em>y</em></code> are numeric expressions in [-32768, 32768].
'attrib' is a numeric expression in <code>[0&mdash;255]</code>. If 'attrib' is specified
and between 0 and the screen mode's palette size, the pixel is changed to 
attribute 'attrib'. If 'attrib' is larger than the palette size, the pixel's
attribute is changed to the highest legal attribute value. 
If 'attrib' is not specified, PSET changes the attribute to the current 
foreground attribute while PRESET changes it to zero.
<h4>Errors</h4>
-   If <code><em>x</em></code> or <code><em>y</em></code> has a string value: <code>Type mismatch</code>.
-   If 'attrib' is not in <code>[0&mdash;255]</code>: <code>Illegal function call</code>.
-   If 'attrib', <code><em>x</em></code> or <code><em>y</em></code> or the physical coordinates they translate into are not in
    <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
 

PRINT, PRINT# and LPRINT statements
{LPRINT| {PRINT|?} [# file_num,]} [expr_0] [;|,|SPC(n)|TAB(n)] [expr_1] [...]
    [ USING format; [ uexpr_0 [ {;|,} uexpr_1 [ {;|,} ...] ] ] [;|,] ]
-----------------------------------
Writes expressions to the screen, printer, file or device. If LPRINT is used, 
output goes to LPT1. If <code><em>file_num</em></code> is specified, output goes to the file or 
device open under that number. ? is a shorthand for PRINT and has the same 
effect. 'expr_0' ... are expressions. 
Expressions can be separated by one of the following tokens:
;   The semicolon attaches two expressions tight together; strings will be 
    printed without any space in between, numbers will have one space 
    separating them, in addition to the space or minus sign that indicate 
    the sign of the number.
,   The expression after a comma will be positioned at the next available
    zone. The output file is divided in 14-character zones; if the width of the
    file is not a multiple of 14, the remaining spaces are unused and the first 
    zone ofn the next line is used instead. If the file has a width of less 
    than 14 characters, the zones are determined as if the file were wrapping 
    continuously.
SPC The expression SPC(n) produces <code><em>n</em></code> spaces, where <code><em>n</em></code> is a numeric 
    expression. if <code><em>n</em></code> is less than zero, it defaults to zero. If <code><em>n</em></code> is 
    greater than the file width, it is taken modulo the file width.      
TAB The expression TAB(n) moves to column <code><em>n</em></code>, where <code><em>n</em></code> is a numeric 
    expression. if <code><em>n</em></code> is less than zero, it defaults to zero. If <code><em>n</em></code> is 
    greater than the file width, it is taken modulo the file width. If the 
    current column is greater than <code><em>n</em></code>, TAB moves to column <code><em>n</em></code> on the next 
    line.     
If the print statement does not end in one of these four tokens, a newline is 
printed after the last expression.         
String expressions can be separated by one or more spaces, which has the same
effect as separating by semicolons
<h4>Notes</h4>
-   If an error is raised, the output before the error was encountered is 
    printed as normal.
-   See below for the syntax of the optional USING declaration
<h4>Errors</h4>
-   If <code><em>n</em></code> is not in [-32768,65535]: <code>Overflow</code>.
-   If <code><em>n</em></code> is a string: <code>Type mismatch</code>.

USING declaration:
------------------
This declaration occurs at the end of an [L]PRINT[#] statement and writes a 
formatted string to the screen, printer, file or device.  
'uexpr_0' ... are expressions. 
'format' is a string expression that specifies the output format of the 
matching expression. The format tokens recognised are -
_   Escape character; causes the next character in the format string to be 
    printed as is rather than interpreted as a format token.
For string expressions:
!   Prints the first character of a string.
\\  Prints 2 or more characters of a string. A greater number of characters is 
    selected by separating the \s by spaces.
&   Prints the whole string.    
For numeric expressions, the format string specifies a width and alignment.
#   indicates a position for a digit.
.   indicates the decimal point.
,   before the decimal point causes digits to be grouped in threes separated by
    commas. After the decimal point it is not a token. 
    Provides one digit position.
The number of characters i the field must not exceed 24.     
Tokens preceding the number field:
+   causes the sign to be printed for positive as well as negative numbers.
    If before the number field, the sign is to be printed to the left of the 
    number. If after the number field, the sign will be printed to the right.
**  causes any leading spaces to be replaced with *s. 
    Provides two digit positions.
$$  causes a $ to be printed to the left of the number.
    Provides one digit position.
Tokens trailing the number field:
+   causes the sign to be printed for positive as well as negative numbers.
    If before the number field, the sign is to be printed to the left of the 
    number. If after the number field, the sign will be printed to the right.
-   after the number field causes the sign for negative numbers to be printed
    to the right of the number. Note that - preceding the field is not a token
    but printed literally.
^^^^ specify that scientific notation E+00 is to be used.    
Numeric expressions are always fully printed, even if they do not fit in the 
positions specified. If the number does not fit in the allowed space, a % is 
printed preceding it.
<h4>Notes</h4>
-   If there are more expressions than format fields, the format string is 
    wrapped around.
-   Expressions may be separated withsemicolons or commas; the effect is the 
    same.
-   If the statement ends in a comma or semicolon, no newline is printed at 
    the end. 
-   After USING, other parts of the PRINT syntax such as SPC( and TAB( can not
    be used.
<h4>Errors</h4>
-   If the expression doesn't match the format token type, <code>Type mismatch</code> is 
    raised.
-   If a number field exceeds 24 characters, <code>Illegal function call</code> .
-   If the format string contains no tokens, <code>Illegal function call</code> .
-   If a number field contains no # characters, ILLEGAL FUCTION CALL .


PUT statement   (random-access files)
PUT [#] file_number [, record_number]
-------------
Writes a record to the random-access file <code><em>file_number</em></code> at position
<code><em>record_number</em></code>. <code><em>file_number</em></code> is a numeric expression that yields the number
of an open random-access file. The # is optional and has no effect. 
<code><em>record_number</em></code> is a numeric expression that gives a number between 1 and
33554432 (2^25), inclusive, and is interpreted as the record number. 
<h4>Errors</h4>
-   If <code><em>record_number</em></code> is not in [1, 33554432]: <code>Bad record number</code>.
-   If <code><em>file_number</em></code> is not in <code>[0&mdash;255]</code>: <code>Illegal function call</code>.
-   If <code><em>file_number</em></code> is not the number of an open file:
    <code>Bad file number</code>.
-   If <code><em>file_number</em></code> is open under a mode other than <code>RANDOM</code>:
    <code>Bad file mode</code>.
-   If <code><em>file_number</em></code> is not specified: <code>Missing operand</code>.
    

PUT statement   (communications)
PUT [#] com_file_number, [, number_bytes]
-------------
Writes <code><em>number_bytes</em></code> bytes to the communications buffer opened under file
number <code><em>com_file_number</em></code>. <code><em>number_bytes</em></code> is a numeric expression between 1
and the COM buffer length, inclusive.
<h4>Notes</h4>
-   In GW-BASIC, DEVICE I/O ERROR is raised for overrun error, framing error,
    and break interrupt. DEVICE FAULT is raised if DSR is lost during I/O. A
    PARITY ERROR is raised if parity is enabled and incorrect parity is 
    encountered. This is according to the manual; it is untested.
<h4>Errors</h4>
-   If <code><em>bytes</em></code> is less than 1: <code>Bad record number</code>
-   If <code><em>bytes</em></code> is less than 32768 and greater than the COM buffer length,
    raises <code>Illegal function call</code>
-   If <code><em>com_file_number</em></code> is not specified: <code>Missing operand</code>.
-   If <code><em>com_file_number</em></code> is not in <code>[0&mdash;255]</code>: <code>Illegal function call</code>.
-   If <code><em>com_file_number</em></code> is not the number of an open file:
    <code>Bad file number</code>.
-   If the serial input buffer is full, i.e. LOF(com_file_number) == 0, and 
    LOC(com_file_number)==255: COMMUNICATION BUFFER <code>Overflow</code>
        
    
PUT statement   (graphics)
PUT (x0, y0), array_name [, {PSET|PRESET|AND|OR|XOR}]
-------------
Displays an array to a rectangular area of the graphics screen. <code><em>array_name</em></code> must
be the name of a numeric array. <code><em>x0</em></code>, <code><em>y0</em></code> are numeric expressions.
Usually, PUT is used with arrays that have been stored using GET. See GET for the
format of the array. 
If specified, the keywords have the following effect:
PSET    Overwrite the screen location with the new image
PRESET  Overwrite the screen location with the inverse image
AND     Combines the old and new attributes with bitwise AND
OR      Combines the old and new attributes with bitwise OR
XOR     Combines the old and new attributes with bitwise XOR
<h4>Errors</h4>
-   If the array does not exist: <code>Illegal function call</code>.
-   If <code><em>array_name</em></code> refers to a string array: <code>Type mismatch</code>.
-   If <code><em>x0</em></code>, <code><em>y0</em></code> are string expressions: <code>Type mismatch</code>.
-   If <code><em>x0</em></code>, <code><em>y0</em></code> are not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
-   If <code><em>x0</em></code>, <code><em>y0</em></code> is outside the current VIEW or WINDOW:
    <code>Illegal function call</code>


RANDOMIZE statement
RANDOMIZE [expr]
-------------------
Seeds the random number generator. 
<code><em>expr</em></code> ia a numeric expression. If specified, this value is used to seed
the random number generator. If not specified, RANDOMIZE will prompt the user
to enter a random seed. The user-provided value is rounded to an integer.
The random seed is formed of the last two bytes of that integer or <code><em>expr</em></code>. 
If <code><em>expr</em></code> is a float (4 or 8 bytes), these are XORed with the preceding 2. The 
first 4 bytes of a double are ignored.
The same random seed will lead to the same sequence of pseudorandom numbers 
being generated by the RND function.
<h4>Notes</h4>
-   For the same seed, PC-BASIC 3.23 produces the same pseudorandom numbers as
    GW-BASIC 3.23.
<h4>Errors</h4>
-   If <code><em>expr</em></code> is a string: <code>Illegal function call</code>.
-   If the user provides a seed outside <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.


READ statement
READ var_0 [, var_1 [, ... ] ]
--------------
Assigns data from a DATA statement to variables. Reading starts at the current
DATA position, which is the DATA entry immediately after the last one read by 
previous READ statements. The DATA position is reset to the start by the RUN 
and RESTORE statements.
'var_0', 'var_1' are valid variable names or array elements.
<h4>Errors</h4>
-   If not enough data is present in DATA statements: OUT OF DATA.
-   If the type of the variable is not compatible with that of the data entry
    being read, a <code>Syntax error</code> is raised on the DATA line.


REM statement
REM [anything]
' [anything]
-------------
Ignores everything until the end of the line. The REM statement is intended for
comments. Everything after REM will be stored in the program unaltered and 
uninterpreted. ' (apostrophe) is an alias for :REM; it can be placed at any 
point in the program line and will ensure that the rest of the line is ignored.


RENUM statement
RENUM [new | .] [, [old | .] [, increment] ]
---------------
Replaces the line numbers in the program by a systematic enumeration starting
from 'new' and increasing by 'increment'. If 'old' is specified, line numbers 
less than 'old remain unchanged.
'new', 'old' are line numbers; the dot . signifies the last line edited.
'increment' is a line number but must not be a dot or zero.
<h4>Notes</h4>
-   The following keywords can reference line numbers, which will be renumbered
    by renum: AUTO, EDIT, ELSE, ERL, DELETE, <code>GOSUB</code>, GOTO, LIST, LLIST, RENUM,
    RESTORE, RESUME, <code>RETURN</code>, RUN, THEN.
-   Some keywords contain line numbers in a different program, which will not be 
    renumbered: CHAIN. However, a line number in a RUN statement that 
    opens a new file *will* be (incorrectly) renumbered. Furthermore, any RENUM 
    or AUTO statements in a program will have all their arguments 'renumbered',
    including line number offsets. This agrees with GW-BASIC's behaviour.    
-   If a referenced line number does not exist in the program, RENUM prints a
    message (not an error) "Undefined line [ref] in [old_line]" where old_line
    is the line number prior to renumbering. The referenced line number will be
    left unchanged, but the line's old line number will be renumbered.
<h4>Errors</h4>
-   If any of the parameters is not in [0, 65529]: <code>Syntax error</code>.
-   If any of the newly generated line numbers is greater than 65529:
    <code>Illegal function call</code>. The line numbers up to the error have not been 
    changed.
-   If 'increment' is empty or zero: <code>Illegal function call</code>.
-   If 'old' is specified and 'new' is less than or equal to an existing line 
    number less than old: <code>Illegal function call</code>.
    
    
RESET statement
RESET
---------------
Closes all open files.


RESTORE statement
RESTORE [line]
-----------------
Resets the DATA pointer.
'line' is a line number. If 'line' is not specified, the DATA pointer os reset
to the first DATA entry in the program. If it is specified, the DATA pointer is
reset to the first DATA entry in or after 'line'.
<h4>Errors</h4>
-   If 'line' is not an existing line number: <code>Undefined line number</code>.
-   If 'line' is not a line number: <code>Undefined line number</code>.


RESUME statement
RESUME [ 0 | NEXT | line ]
----------------
Continues normal execution after an error handling routine. 
If 0 or no option is specified, re-executes the statement that caused the 
error. If NEXT is specified, executes the statement following the one that 
caused the error. If 'line' is specified, it must be a valid line number.
<h4>Errors</h4>
-   If RESUME is encountered outside of an error trapping routine:
    RESUME WITHOUT ERROR.
-   If the program ends inside an error trapping routine without a RESUME 
    or END statement: NO RESUME.
-   If 'line' is not an existing line number: <code>Undefined line number</code>.
    

<code>RETURN</code> statement
<code>RETURN</code> [line]
----------------
Returns from a <code>GOSUB</code> subroutine. If 'line' is not specified, <code>RETURN</code> jumps back
to the statement after the <code>GOSUB</code> that jumped into the subroutine.
If 'line' is specified, it must be a valid line number. <code>RETURN</code> jumps to that
line (and pops the <code>GOSUB</code> stack).
When returning from an error trapping routine, <code>RETURN</code> re-enables the event
trapping which was stopped on entering the trap routine.
<h4>Errors</h4>
-   If 'line' is not an existing line number: <code>Undefined line number</code>.


RIGHT$ function
child = RIGHT$(parent, num_chars)
--------------
Returns the rightmost <code><em>num_chars</em></code> characters of 'parent'. 'parent' must be a 
string expression. <code><em>num_chars</em></code> must be a numeric expression between 0 
and 255, inclusive. If <code><em>num_chars</em></code> is zero or 'parent' is empty, RIGHT$ returns
an empty string "". If <code><em>num_chars</em></code> is greater than the length of 'parent', 
returns 'parent'.
<h4>Errors</h4>
-   If <code><em>num_chars</em></code> is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
-   If <code><em>num_chars</em></code> is not in <code>[0&mdash;255]</code>: <code>Illegal function call</code>.
-   If <code><em>num_chars</em></code> has a string value: <code>Type mismatch</code>.
    
    
RMDIR statement
RMDIR path
---------------
Removes an empty directory. 'path' is a string expression that specifies 
the path of the directory.  RMDIR first looks for the exact, case-sensitive (on
Unix) path <code><em>pathname</em></code>; if this does not exist then an uppercase version 
truncated to 8.3 is attempted. The search will match the first 8.3 filename 
(in lexicographic order) whose uppercase version equals the requested name. 
<h4>Errors</h4>
-  If no matching path is found, <code>Path not found</code> .
-  If <code><em>pathname</em></code> is not string, <code>Type mismatch</code> .
-  If <code><em>pathname</em></code> is empty, <code>Bad file name</code> .
    

RND function
random = RND[(x)]
------------
Returns a pseudorandom number in the range [0,1].
<code><em>x</em></code> is a numeric expression. If <code><em>x</em></code> is zero, RND repeats the last pseudo-
random number. If <code><em>x</em></code> is greater than zero, a new pseudorandom number is 
returned. If <code><em>x</em></code> is negative, the value of <code><em>x</em></code> is used to generate a new 
random number seed; after that, a new pseudorandom number is returned.
Note that the seed is generated in a different way than by RANDOMIZE.
<h4>Errors</h4>
-   If <code><em>x</em></code> is a string, <code>Type mismatch</code> .

    
<h3><code>RSET</code> statement</h3>
<p>See <code>LSET</code></p>.


RUN statement
RUN [line|filename] [,R]
-------------
Executes the program in memory.
If 'line' is specified, it must be a valid line number in the current program. 
Execution starts from this line number.
If <code><em>filename</em></code> is specified, the file with that name is loaded and executed.
RUN,R keeps all data files open. Existing variables will be 
cleared and any program in memory will be erased. RUN implies a CLEAR.
<h4>Errors</h4>
-   If 'line' does not exist: <code>Undefined line number</code>.
-   If <code><em>filename</em></code> cannot be found: <code>File not found</code>.
-   If <code><em>filename</em></code> is an empty string: <code>Bad file number</code>.
-   If a loaded ASCII file contains lines without line numbers:
    DIRECT STATEMENT IN FILE.


SAVE statement
SAVE filename [,{A|P}]
--------------
Stores the program in file <code><em>filename</em></code>. If <code><em>filename</em></code> is not in 8.3 uppercase
format, additional characters will be clipped off and the name is converted to
uppercase. If <code><em>filename</em></code> contains no dot (.), a default extension of .BAS will
be added. If the resulting file name already exists, it will be overwritten.
If ,A is specified, the program will be saved as plain ASCII. 
If ,P is specified, the program will be saved in encrypted form. When an 
encrypted program is loaded, it cannot be LISTed or SAVEd in non-encrypted 
form.
<h4>Notes</h4>
-   In PC-BASIC 3.23, use the --conv option to convert any file type to any 
    other file type, including encrypted to ASCII or bytecode.
<h4>Errors</h4>
-   If <code><em>filename</em></code> has a number value: <code>Type mismatch</code>.
-   If <code><em>filename</em></code> is an empty string: <code>Bad file number</code>.
-   If the current program is encrypted and ,P is not specified:
    <code>Illegal function call</code>.


SCREEN function
value = SCREEN(row, column [, fn])
---------------
Returns the ASCII code or colour attribute for the character at position 
'row', 'col'. 
'row' is a numeric expression in the range [1,25].
'col' is a numeric expression between 1 and the screen width (40 or 80).
'fn' is a numeric expression in <code>[0&mdash;255]</code>. If it is zero or not specified,
the ASCII code of the character is returned. If it is non-zero, in SCREEN 0 the
attribute is returned; in other screens, 0 is returned.
<h4>Errors</h4>
-   If any parameter has a string value: <code>Type mismatch</code>.
-   If 'fn' is not in <code>[0&mdash;255]</code>: <code>Illegal function call</code>.
-   If 'fn' is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
-   If 'row' is not inside the current VIEW PRINT area:
    <code>Illegal function call</code>.
-   If KEY ON and 'row'=25: <code>Illegal function call</code>.
-   If 'col' is not in [1, width]: <code>Illegal function call</code>.


SCREEN statement
SCREEN [mode] [, [colorburst] [, [apage] [, vpage] ] ]
----------------
Change the screen resolution mode. The modes are described at the start of this
document.
'mode' is a numeric expression that sets the screen mode.
'apage' is a numeric expression that sets the active page.
'vpage' is a numeric expression that sets the visible page.
'colorburst' is a numeric expression; if the switch setting changes between 
zero and non-zero, the screen is cleared. 
On CGA, Tandy and PCjr, 'colorburst' has the following effects, depending on the 
type of monitor - RGB (default) or composite:
SCREEN  value   CGA mode    effect on composite     effect on RGB
    0       0   0, 2        greyscale               colour
    0       1   1, 3        colour                  colour
    1       0   4           colour                  colour 
    1       1   5           greyscale               colour (alternate palette)
On SCREEN 2, 'colorburst' has no effect; on a composite monitor, colour artifacts 
can be enabled on this screen through OUT (see there).    
NOTE:
-   At least one parameter must be specified.
-   Composite colour artifacts are emulated only crudely in PC-BASIC, and not at
    all in SCREEN 1.
<h4>Errors</h4>
-   If no parameters are specified: <code>Missing operand</code>.
-   If any parameter has a string value: <code>Type mismatch</code>.
-   If any parameter is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
-   If 'mode' is not in 0,1,2,7,8,9: <code>Illegal function call</code>.
-   If 'vpage', 'apage' are not between 0 and the number of pages for the 
    screen chosen, less one: ILLEGAL FUNCION CALL.
-   If 'colorburst' is not in <code>[0&mdash;255]</code>: <code>Illegal function call</code>.


SGN function
sign = SGN(number)
------------
Returns the sign of <code><em>number</em></code>. <code><em>number</em></code> is a numeric expression.
If <code><em>number</em></code> is greater than zero, returns 1; 
if <code><em>number</em></code> equals zero, returns 0;
if <code><em>number</em></code> is less than zero, returns -1.
<h4>Errors</h4>
-   If <code><em>number</em></code> has a string value: <code>Type mismatch</code>.


SHELL statement [--allow-shell only]
SHELL [command]
---------------
Starts a subshell on the console.   
The type of shell is determined by your OS. On Unix systems, an sh shell is 
started. On Windows systems, a CMD.EXE shell is started. 
'command' is a string expression.
If 'command' is specified, the command is executed on the shell and execution
returns to the program.
<h4>Notes</h4>
-   If the --allow-shell option is not specified, this statement does nothing.
<h4>Errors</h4>
-   If 'command' has a number value: <code>Type mismatch</code>.
-   All output including errors from the operating system subshell is displayed
    on the PC-BASIC 3.23 screen.


SIN function
sine = SIN(angle)
------------
Returns the sine of <code><em>angle</em></code>. <code><em>angle</em></code> is a numeric expression that gives 
the angle in radians. 
Unless BASIC is run with the --double option, SIN(x) returns a single-precision
value.
<h4>Notes</h4>
-   SIN(x) usually differs from the value returned by GW-BASIC. For one-digit 
    values, the difference is only in the least significant figure, but it
    increases with the size of the angle.
<h4>Errors</h4>
-   If <code><em>x</em></code> has a string value, SIN raises <code>Type mismatch</code>.
     

SOUND statement
SOUND frequency, duration
SOUND frequency, duration [, volume [, voice] ]       [pcjr and tandy only]
---------------
Produces a sound at 'frequency' Hz for 'duration'/18.2 seconds.
'frequency' is a numeric expression in [37, 32767] or 0.
'duration' is a numeric expression in [0, 65535]. 
If PLAY "MB" has been executed, SOUND playes in the background. If PLAY "MF" 
has been executed, sound plays in the foreground and the interpreter blocks
until the sound is finished. Foreground mode is default. Unlike PLAY, the 
sound played by the most recent SOUND statement always plays in the background,
even if PLAY "MF" has been entered. In background mode, each SOUND statement 
counts as 1 toward the length of the queue reported by the PLAY function.
PCJR and TANDY:
    'frequency' is a numeric expression in <code>[-32768&mdash;32767]</code> (on Tandy)
    or [37, 32767] if nonzero (on PCjr). 
    Frequencies below 110 Hz are played as 110 Hz.
    If 'duration' is zero, 'volume' and 'voice' must not be specified.
    'volume' is a numeric expression in [0, 15]. 0 is silent, 15 is full
    volume; every step less reduces the volume by 2 dB.
    'voice' is a numeric expression in [0, 2], indicating which of the 
    three tone voice channels is used for this sound.
<h4>Notes</h4>
-   If 'duration' is zero, any active background sound is stopped and 
    the sound queue is emptied.
-   If 'duration' is less than .022 but nonzero, the sound will be played in 
    background and continue indefinitely until another sound statement is 
    executed. This is also the behaviour for negative 'duration'.
-   If 'frequency' equals 32767 or 0, a silence of length 'duration' is queued.
<h4>Errors</h4>
-   If 'frequency' is not in its allowed range, and 'duration' is not zero, 
    raises <code>Illegal function call</code>.
-   If 'duration' is zero, specifying more than two aruments raises
    <code>Syntax error</code>.    
-   If 'frequency' is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
-   If 'duration' is not in [-65535, 65535]: <code>Illegal function call</code>.
-   If 'volume' is not in [0, 15]: <code>Illegal function call</code>.
-   If 'voice' is not in [0, 2]: <code>Illegal function call</code>.


SOUND statement (advanced-sound switch)            [pcjr and tandy syntax only]
SOUND {ON | OFF}
---------------
PCJR and TANDY:
    Toggles the availability of advanced sound capabilities, including 3-voice 
    sound, noise generation and volume control.
<h4>Notes</h4>
-   On PCjr and Tandy computers, SOUND ON would turn on the external speaker as
    well as make advanced sound capabilities available. On PC-BASIC, both the
    internal and the external speaker are emulated through the same sound
    system.

SPACE$ function
spaces = SPACE$(number)
---------------
Returns a string of <code><em>number</em></code> spaces.
<code><em>number</em></code> is a numeric expression in <code>[0&mdash;255]</code>.
<h4>Errors</h4>
-   If <code><em>number</em></code> is a string: <code>Type mismatch</code>
-   If <code><em>number</em></code> is not in <code>[0&mdash;255]</code>: <code>Illegal function call</code>.
-   If <code><em>number</em></code> is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.


SQR function
root = SQR(number)
------------
Returns the square root of <code><em>number</em></code>. 
<code><em>number</em></code> is a numeric expression.
The return value is a single-precision float unless PC-BASIC 3.23 is run with
the --double option, in which case the precision matches that of <code><em>number</em></code>.
<h4>Errors</h4>
-   If <code><em>number</em></code> is a string: <code>Type mismatch</code>


STICK function
pos = STICK(axis)
--------------
Returns q coordinate of a joystick axis. All coordinates returned are in the 
range [1,254] with 128 indicating the neutral position.
'axis' is a numeric expression in [0,3] and indicates which axis to read.
'axis'  return value
    0   1st joystick x coordinate
    1   1st joystick y coordinate
    2   2nd joystick x coordinate
    3   2nd joystick y coordinate
<h4>Errors</h4>
-   If 'axis' is a string: <code>Type mismatch</code>
-   If 'axis' is not in [0,3]: <code>Illegal function call</code>.
-   If 'axis' is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.


STOP statement
STOP
--------------
Breaks program execution and returns to interactive mode. STOP prints a Break 
message on the console. Files are not closed. It is possible to resume 
execution at the next statement using CONT.


STR$ function
repr = STR$(number)
-------------
Returns the string representation of <code><em>number</em></code>.
<code><em>number</em></code> is a numeric expression.
<h4>Errors</h4>
-   If <code><em>number</em></code> is a string: <code>Type mismatch</code>.


STRIG statement (overall)
STRIG { ON | OFF }
---------------
Has no effect.


STRIG statement (events)
STRIG(button) { ON | OFF | STOP }
---------------
Controls event trapping of the joystick trigger 'button'. If ON is specified
event trapping is switched on; if OFF, off. STOP suspends event trapping until 
another STRIG() ON is executed. Up to one event can be triggered during 
suspension, provided that event handling was switched on prior to suspension. 
The event triggered during suspension is handled immediately after the next ON
statement.
'button' must be a numeric expression in [0,2,4,6]:
0   joystick 1, trigger 1
2   joystick 2, trigger 1
4   joystick 1, trigger 2
6   joystick 2, trigger 2
<h4>Errors</h4>
-   If 'button' is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
-   If 'button' is not in [0,2,4,6]: <code>Illegal function call</code>.
-   If 'button' has a string value: <code>Type mismatch</code>.


STRIG function
result = STRIG(mode)
--------------
Returns the status of the joystick trigger buttons.
'mode' is a numeric expression in [0, 7]. STRIG returns the following 
results, all boolean values:
'mode'  STRIG result
  0     whether 1st joystick, 1st trigger has been pressed since last poll.
  1     whether 1st joystick, 1st trigger is currently pressed.
  2     whether 2nd joystick, 1st trigger has been pressed since last poll.
  3     whether 2nd joystick, 1st trigger is currently pressed.
  4     whether 1st joystick, 2nd trigger has been pressed since last poll.
  5     whether 1st joystick, 2nd trigger is currently pressed.
  6     whether 2nd joystick, 2nd trigger has been pressed since last poll.
  7     whether 2nd joystick, 2nd trigger is currently pressed.
<h4>Notes</h4>
-   The STRIG function returns correct results regardless of the STRIG ON 
    status or whether STRIG(0) has been called first.
<h4>Errors</h4>
-   If 'mode' is a string: <code>Type mismatch</code>.
-   If 'mode' is not in [0, 97: <code>Illegal function call</code>.
-   If 'mode' is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.


STRING$ function
string = STRING$(length, char)
----------------
Returns a string of n times character 'char'.
If 'char' is a numeric expression, it must be between 0 and 255 and is
interprested as the ASCII value of the character.
If 'char' is a string expression, its first character is used.
<h4>Errors</h4>
-   If 'char' is the empty string: <code>Illegal function call</code>.
-   If 'char' or 'length' is not in <code>[0&mdash;255]</code>: <code>Illegal function call</code>.
-   If 'char' or 'length' is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.


SWAP statement
SWAP var_0, var_1
--------------
Exchanges the values of 'var_0' and 'var_1', which must be variable names of 
the exact same type.
<h4>Errors</h4>
-   If 'var_0' or 'var_1' is undefined: <code>Illegal function call</code>.
-   If the types of 'var_0' and 'var_1' are not the same: <code>Type mismatch</code>.


SYSTEM statement
SYSTEM
----------------
Exits the interpreter. 
<h4>Notes</h4>
-   SYSTEM closes the BASIC interpreter immediately without prompt.
    Any unsaved program will be lost.


TAN function
tangent = TAN(angle)
------------
Returns the sine of <code><em>angle</em></code>. <code><em>angle</em></code> is a numeric expression that gives 
the angle in radians. 
Unless BASIC is run with the --double option, TAN returns a single-precision
value.
<h4>Notes</h4>
-   TAN(x) usually differs from the value returned by GW-BASIC. For one-digit 
    values, the difference is only in the least significant figure, but it
    increases with the size of the angle.
-   For <code><em>angle</em></code> close to multiples of PI/2, the tangent is divergent or close
    to zero. The values returned will have very low precision in these cases.
<h4>Errors</h4>
-   If <code><em>angle</em></code> has a string value, SIN raises <code>Type mismatch</code>.


TERM statement                                     [pcjr and tandy syntax only]
TERM 
-------------
PCJR:
    Starts a built-in serial terminal emulator application. 
    This is a BASIC program that is loaded and run instead of the current 
    program.
TANDY:
    Raises INTERNAL ERROR.
DEFAULT:
    In default mode, this keyword is not present.


TIME$ function
time = TIME$
--------------
Returns the current BASIC time in the form "HH:mm:ss".


TIME$ statement
TIME$ = time
---------------
Sets the current BASIC time to 'time'. Time must be a string expression
of the form "HH:mm:ss" where <code>00&lt;=HH&lt;24</code>, <code>00&lt;=mm&lt;60</code> and <code>00&lt;=ss&lt;60</code>.
<h4>Notes</h4>
-   PC-BASIC 3.23stores an offset to the system time and uses this for future 
    calls to TIME and DATE functions in the same interpreter session. The 
    system time is not changed, unlike GW-BASIC under MS-DOS.
<h4>Errors</h4>
-   If 'time' is not a string: <code>Type mismatch</code>.
-   If 'time' is not of the correct form: <code>Illegal function call</code>.


TIMER function
ticks = TIMER
--------------
Returns the number of seconds since midnight, as defined by the internal BASIC 
time.
<h4>Notes</h4>
-   TIMER updates in ticks of 1/20 second.
-   The least-significant two bytes of TIMER are often used as a seed for the 
    pseudorandom number generator through RANDOMIZE TIMER. Since these bytes
    only take values from a limited set, that's not in fact a particularly good
    random seed. However, the pseudorandom number generator included with BASIC
    is so weak that is should not be used for anything serious anyway.
    

TRON and TROFF statements
TR{ON|OFF}
-------------------------
Turns line number tracing on or off. If line number tracing is on, BASIC prints
a tag [100] to the screen when program line 100 is executed, and so forth.
<h4>Notes</h4>
-   Tracing is turned off by the NEW and LOAD statements.
-   There must be no space between TR and ON or OFF.


UNLOCK statement
UNLOCK [#] file_number [, record_0 ]
UNLOCK [#] file_number, [record_0] TO record_1
----------------
Unlocks a file or part of it that has previously been locked with LOCK. 
<h4>Errors</h4>
-   If <code><em>file_number</em></code> is open for <code>RANDOM</code>, LOCK and UNLOCK statements must match
    in terms of 'record_0' and 'record_1'. An unmatching UNLOCK will raise      
    PERMISSION DENIED.
-   If 'record_0' or 'record_1' is not in [1, 2^25-2]: <code>Bad record number</code>.
-   If <code><em>file_num</em></code> is not an open file: <code>Bad file number</code>.
-   If <code><em>file_num</em></code> is not in <code>[0&mdash;255]</code>: <code>Illegal function call</code>.
-   If <code><em>file_num</em></code> is not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
-   If any parameter is a string: <code>Type mismatch</code>.


USR function
value = USR[n](expr)
------------
Returns zero.
<code><em>n</em></code> is a digit between 0 and 9 inclusive. 
<code><em>expr</em></code> is an expression.
<h4>Notes</h4>
-   In GW-BASIC, calls an assembly-language function and returns a value.
    This is not implemented in PC-BASIC 3.23.
<h4>Errors</h4>
-   If <code><em>n</em></code> is not a digit 0--9: <code>Syntax error</code>.


VAL function
value = VAL(string)
------------
Returns the numeric value of the string -valued expression 'string'. 
The interpretation is the same a that used in program lines. For instance, 
spaces before or even inside a number are ignored: VAL(" 1 0") returns 10. 
Parsing stops as soon as the first character is encountered that cannot be 
part of a number. If that is the first character of the string, or the 
string is empty, VAL returns zero. 
<h4>Errors</h4>
-   If 'string' has a number value: <code>Type mismatch</code>.


VARPTR function
pointer = VARPTR(name)
pointer = VARPTR(#file_num)
---------------
Returns the memory address of variable <code><em>name</em></code>. <code><em>name</em></code> must be the name of a
previously defined variable or fully indexed array element. The value of VAPTR 
can be used with PEEK to read the variable's internal representation.
In the second syntax, return the memory address of the File Control Block of 
file number <code><em>file_num</em></code>.
<h4>Notes</h4>
-   In PC-BASIC 3.23, VARPTR is implemented for all variable and array types,
    except arrays of strings.
<h4>Errors</h4>
-   If <code><em>name</em></code> is not previously defined: <code>Illegal function call</code>.
-   If <code><em>file_num</em></code> is not in [1, max number of files]: <code>Bad file number</code>.
-   If <code><em>file_num</em></code> has a string value: <code>Type mismatch</code>.


VARPTR$ function
pointer = VARPTR$(name)
----------------
Returns the memory address of variable <code><em>name</em></code> in the form of a 3-byte string.
The first byte is the length of the record the pointer points to: 
    2   for integer
    3   for strings (length + pointer to string space)
    4   for single-precision floats
    8   for double-precision floats
The last two bytes are the pointer address (as returned by VARPTR) in little-
endian order.
<h4>Errors</h4>
-   If <code><em>name</em></code> is not previously defined: <code>Illegal function call</code>.


VIEW statement
VIEW [ [SCREEN] (x0,y0)-(x1,y1) [, [fill] [, border]] ]
--------------
Defines a graphics clipping area. Graphics drawn outside the clipping area will
not be shown. <code><em>x0</em></code>, <code><em>y0</em></code>, <code><em>x1</em></code>, y1' are absolute screen coordinates of two
opposing corners of the area.
If 'fill' is specified, it must be a valid attribute. The clipping area will be
filled with this attribute.
If <code><em>border</em></code> is specified, it must be a valid attribute. A border will be drawn 
with this attribute just outside the clipping area.
Unless SCREEN is specified, after a VIEW statements the 'physical' coordinate 
system is shifted such that (0,0) becomes the top left coordinate of the 
clipping area.
If VIEW is called without arguments, the clipping area is reset to the whole
screen.
<h4>Errors</h4>
-   If any of the coordinates is not in <code>[-32768&mdash;32767]</code>, <code>Overflow</code> .
-   If any of the coordinate pairs is outside the physical screen, 
    raises <code>Illegal function call</code>.
-   If any of the parameters has a string value: <code>Type mismatch</code>.


VIEW PRINT statement
VIEW PRINT [top_row] TO [bottom_row]
--------------------
Defines the text scrolling area of the screen. 'top_row' and 'bottom_row' are
numeric expressions in the range 1 to 24, inclusive. LOCATE statements,
cursor movement and scrolling ill be limited to the scroll area.
<h4>Notes</h4>
-   Regardless of the KEY ON|OFF setting, screen row 25 cannot be part fo the 
    scrolling area.
<h4>Errors</h4>
-   If 'top_row' or 'bottom_row' is not in [1,24], <code>Illegal function call</code> is 
    raised. On Tandy/PCjr, 'bottom_row' may be 25 if KEY OFF.



WAIT statement
WAIT port, and_mask [, xor_mask]
--------------
Waits for the value of (INP(port) XOR xor_mask) AND and_mask to become nonzero.
Events are STOPped until WAIT returns. If xor_mask is not specified, its 
default is 0.
<h4>Notes</h4>
-   In GW-BASIC, waits for machine port <code><em>port</em></code> to turn to a specific value. 
    This is not implemented in PC_BASIC 3.23, except for use cases discussed
    at INP.
<h4>Errors</h4>
-   If <code><em>port</em></code> is not in <code>[-32768&mdash;65535]</code>, <code>Overflow</code> .
-   If any parameter has a string value, <code>Type mismatch</code> .
-   If 'and_mask' or 'xor_mask' are not in <code>[0&mdash;255]</code>: <code>Type mismatch</code>.


WEND statement
WEND
--------------
Iterates a WHILE--WEND loop: jumps to the matching WHILE statement, where its 
condition can be checked.
<h4>Notes</h4>
-   WHILE--WEND statements can be nested; WEND jumps to the most recent WHILE 
    statement that has not been closed by another WEND.
<h4>Errors</h4>
-   If all previous WHILE statements have been closed by WEND:
    <code>WEND without WHILE</code>.


WHILE statement
WHILE expr
---------------
Initiates a WHILE--WEND loop. 
<code><em>expr</em></code> is a numeric expression. If <code><em>expr</em></code> evaluates to zero, WHILE jumps 
to the statement immediately after the matching WEND. If not, execution
continues. 
<h4>Errors</h4>
-   If no matching END is found: <code>WHILE without WEND</code>.
-   If <code><em>expr</em></code> is a string: <code>Type mismatch</code>.


WIDTH statement
WIDTH { # file_num | device_name | LPRINT }, num_columns 
WIDTH { 20 | 40 | 80 | (num_columns) } [, [num_rows] [,]]
---------------
Set the line width for the screen, a file or a device.
'num_columns' is a numeric expression between 0 and the new column width. 
When a write operation passes beyond the column width, a CR/LF sequence is 
inserted. 
<code><em>file_num</em></code> is a numeric expression that is the numer of an open file. 
If specified, the width for operations through that file  number will be 
changed.
'device_name' is a string expression that is one of the devices
 KYBD:, SCRN:, LPT1:, LPT2:, LPT3:, COM1:, COM2:, CAS1:
If a device is specified, it does not need to be open; the width setting will
be the default width next time a file is opened to that device.
If 'device_name' is "SCRN:", "KYBD:", or omitted, the screen width is changed.
In this case, 'num_columns' must be one of 20, 40 or 80.
If 'device_name' is "LPT1:" or LPRINT is specified, the device width setting 
affects LPRINT and LLIST.
'num_rows' is optional and must equal 25. 
<h4>Notes</h4>
-   In GW-BASIC, in the second syntax, num_columnns can only be an expression 
    if it is bracketed. Otherwise it must be a literal 40 or 80. PC-BASIC
    accepts unbracketed expressions, as long as they evaluate to 40 or 80.
-   In the second syntax, the trailing comma is optional and have no effect.
-   When changing screen width in graphics mode, the screen mode is changed.
    The following changes occur:
        SCREEN 1 (40)  <-->  SCREEN 2 (80)
        SCREEN 7 (40)  <-->  SCREEN 8 (80)
        SCREEN 7 (40)  <---- SCREEN 9 (80)
-   Width value 20 is only allowed on Tandy and PCjr. Changing to this width
    changes to graphical SCREEN 3. Additionally, the following changes occur:
        SCREEN 3 (20) ---->  SCREEN 1 (40)
        SCREEN 3 (20) ---->  SCREEN 2 (80)
        SCREEN 4 (40) ---->  SCREEN 2 (80)
        SCREEN 5 (40)  <-->  SCREEN 6 (80)
-   On Tandy and PCjr, 'num_rows' may be in [0,25] but its value is ignored.
<h4>Errors</h4>
-   If 'device_name' is not one of the allowed devices: <code>Bad file name</code>.
-   If 'device_name' is SCRN:, KYBD: or omitted, and num_columns is not 40 or 
    80: <code>Illegal function call</code>.
-   If <code><em>file_num</em></code> is not an open file: <code>Bad file mode</code>.
-   If <code><em>file_num</em></code> or 'num_columns' are strings: <code>Type mismatch</code>.
-   If <code><em>file_num</em></code> or 'num_columns' are not in <code>[0&mdash;255]</code>:
    <code>Illegal function call</code>.
-   If <code><em>file_num</em></code> or 'num_columns' are not in <code>[-32768&mdash;32767]</code>: <code>Overflow</code>.
-   In the second syntax, if an unbracketed expression is used, 
    <code>Illegal function call</code> .
-   If 'num_rows' is not in its accepted range: <code>Illegal function call</code>.
    

WINDOW statement
WINDOW [ [SCREEN] (x0,y0)-(x1,y1) ]
----------------
Define logical coordinates for the screen.
<code><em>x0</em></code>, <code><em>y0</em></code>, <code><em>x1</em></code>, <code><em>y1</em></code> are numeric expressions.
If SCREEN is not specified,
the bottom left of the screen is mapped to the lower coordinates;
the top right of the screen is mapped to the higher coordinates.
If SCREEN is specified,
the top left of the screen is mapped to the lower coordinates;
the bottom right of the screen is mapped to the higher coordinates.
If WINDOW is called without arguments, the logical coordinates are 
reset to the physical ones.
<h4>Errors</h4>
-   If any of the coordinates are strings, <code>Type mismatch</code> .
-   If <code><em>x0</em></code>=<code><em>x1</em></code> or <code><em>y0</em></code>=<code><em>y1</em></code>: <code>Illegal function call</code>.


WRITE and WRITE# statements
WRITE [#file_num,] expr_0 [ {,|;} expr_1 [...] ]
---------------------------
Writes values to a file or the screen in machine-readable form. Values are
separated by commas and the line is ended with a CR/LF sequence. Strings are 
delimited by double quotes ". No padding spaces are inserted.
'expr_0', ... are expressions whose value is to be printed.
<h4>Errors</h4>
-   If <code><em>file_num</em></code> is a string, <code>Type mismatch</code> .
-   If <code><em>file_num</em></code> is open for INPUT, <code>Bad file mode</code> .




<h2>Error codes</h2>
<pre>
1   NEXT without FOR
2   Syntax error
3   <code>RETURN</code> without <code>GOSUB</code>
4   Out of DATA
5   Illegal function call
6   Overflow
7   Out of memory
8   Undefined line number
9   Subscript out of range
10  Duplicate Definition
11  Division by zero
12  Illegal direct
13  Type mismatch
14  Out of string space
15  String too long
16  String formula too complex
17  Can't continue
18  Undefined user function
19  No RESUME
20  RESUME without error
21
22  Missing operand
23  Line buffer overflow
24  Device Timeout
25  Device Fault
26  FOR without NEXT
27  Out of paper
28
29  WHILE without WEND
30  WEND without WHILE
31--49
50  FIELD overflow
51  Internal error
52  Bad file number
53  File not found
54  Bad file mode
55  File already open
56
57  Device I/O error
58  File already exists
59--60
61  Disk full
62  Input past end
63  Bad record number
64  Bad file name
65
66  Direct statement in file
67  Too many files
68  Device Unavailable
69  Communication buffer overflow
70  Permission Denied
71  Disk not Ready
72  Disk media error
73  Advanced Feature
74  Rename across disks
75  Path/File access error
76  Path not found
77  Deadlock
</pre>
Any error code that does not have a message associated to it will generate
the message "Unprintable error".


LITERALS
--------
String literals can be specified between double quotes. There is no escaping
mechanism. To include a double quote or a special character in a string, use
the CHR$() function.
Numeric literals:
  [{+|-}] [digits] [.] [digits] [ { {E|D} [{+|-}] [digits] | # | ! | % } ]
  &{H|h}hexadecimal_digits
  &[O|o]octal_digits
Trailing % is ignored, ! or # specify the type.
Examples of valid numeric literals:
  -1
  42
  42!
  42#
  1.3523523
  .235435
  -.3
  3.
  .         (this equals 0!)
  .e        (0!)
  .D        (0#)
  1.1e+7
  1.1d+7
  1e2
  1e-2
  &7
  &hffff
  &O20
Hexadecimal literals can be specified like &HFFFF. They must range between 
-&H7FFF and &HFFFF. &HFFFF = -&H1 = &H-1 .
Octal literals can be specified as &o777 or &777.


VARIABLES
---------
Variable names must start with a letter; all characters of the variable name
(except the type character) must be letters (A-Z), figures (0-9), or a dot (.)
Only the first 40 characters in the name are significant. Variable names must
not be identical to keywords -- roughly, statement or function names; more 
accurately, anything that has a defined keyword token, including such words as
TO but not, for instance, AS. There is no particular logic to this. Variable
names may start with a keyword, with the exception of USR and FN. Thus, FNORD$
is not a legal variable name while FRECKLE% is. For each name, four different 
variables may exist corresponding to the four types. That is, you can have A$, 
A%, A! and A# with different values. Which one of those is called A depends on 
the settings in DEFINT/DEFDBL/DEFSNG/DEFSTR. The default is A==A!. In addition,
you can have arrays A$(), A%(), A!(), A#() which are separate from the scalar 
variables of the same name.


TYPES
-----
PC-BASIC recognises four variable types, distinguished by their type character
which is the last character of the variable's name:
char    type                    size
 $      string                  3 bytes plus allocated string space
 %      integer                 2 bytes 
 !      single-precision float  4 bytes
 #      double-precision float  8 bytes 
If the type character is not specified, the first letter of the name determines
the type through DEFINT/DEFSTR/DEFSNG/DEFDBL. Unless otherwise specified, all
variables are single-precision floats.
Internal representation:
-   Line numbers are two-byte unsigned little-endian.
-   Integers are two-byte signed little-endian two's complement ints.
-   Booleans are represented as 0 (FALSE); -1 or other non-zero (TRUE). 
-   Floats are represented in the Microsoft Binary Format (MBF).
Machine limits:
    Line numbers are in [0, 65529]. 65530-65535 are unused.
    Integers are in <code>[-32768&mdash;32767]</code>. 
    Floats: largest 1.701412E+38; smallest 2.938726E-39
    Double-precision floats can hold more decimals but not larger or smaller 
    numbers.


FLOATING POINT: THE MICROSOFT BINARY FORMAT
------------------------------------------------------------------
GW-BASIC's floating point numbers are implemented in Microsoft Binary Format 
(MBF), which differs from the now ubiquitous IEEE 754 format. PC-BASIC follows
this implementation. Consequently, binary files generated by either BASIC are 
fully compatible with each other and with some applications contemporary to 
GW-BASIC, but not easily interchanged with other software. QBASIC uses IEEE 754 
floats. 
The MBF differs from IEEE 754 in positioning the sign bit in a mantissa byte
rather than the exponent, and in using only an 8-bit exponent even for double
precision, making the range of allowable numbers in double precision smaller,
but their precision higher, than for an IEEE double.
Schematically, MBF floating point numbers are represented as follows.
single precision:
          offset                       00 | 01 | 02 | 03 
             use                       m3 | m2 | m1 | exp
double precision:
          offset   00 | 01 | 02 | 03 | 04 | 05 | 06 | 07               
             use   m7 | m6 | m5 | m4 | m3 | m2 | m1 | exp
where:
     exp is the exponent byte
     m1 is most significant mantissa byte:   m1 =  s f1 f2 f3 f4 f5 f6 f7                  
     m2--m7 are of decreasing significance:  m2 = f8 f9 fA fB fC fD fE fF, etc.          
     s = sign bit                                   
     f = fraction bit                                              
sign:
    If the sign bit is set, the number is negative.     
mantissa:
    There is an assumed 1 bit after the radix point, so the mantissa binary 
    fraction is 0 . 1 f0 f1 f2 ... where f's are the fraction bits.
exponent:
    The exponent is biased by 128: the mantissa fraction is multiplied by
    2 ^ (exp - 128).
zero:
    Any float with the exponent byte set to 0 is interpreted as a zero.
A single-precision MBF float therefore has 23 bits of precision, while a double
precision MBF float has 55 bits of precision.
    
    
ARRAYS
------
Arrays of any type can be generated. Arrays are indexed with round or square 
brackets; even mixing brackets is allowed. The following work: A[0] A(0) 
A(0] A[0). Multidimensional arrays are specified with commas: A(0,0) etc.
By default, arrays are counted from 0. This can be changed to 1 using 
 OPTION BASE 1. Arrays can be allocated using DIM. If all indices of the array
are 10 or less, arrays can be used without using the DIM command. The first 

referencing of the array (read or write) will automatically dimension it with 
a maximum index of 10 and the same number of indices as in the first 
referencing. To re-allocate an array, first the old array must be deleted 
through CLEAR or ERASE.


OPERATORS
---------
Order of precedence:    
    ^	Exponentiation
    -	Negation
    *	Multiplication  
    /	Floating-point Division   \   Integer division   MOD  Integer modulo
    +	Addition   - Subtraction
NOTE: Exponentiation is tighter bound than negation: -1^2 = -1 but (-1)^2 = 1.
Relational:
    =       Equal
    <> ><   Not equal
    <       Less than
    >       Greater than
    <= =<   Less than or equal
    >= =>   Greater than or equal
Boolean:
    NOT, AND, OR, XOR, EQV, IMP


SCREEN MODES, ATTRIBUTES, PALETTES AND COLOURS
----------------------------------------------
The emulated VGA adapter can produce more colours than can be shown on the 
screen at one time. These colours can be used by assigning them to attributes 
in a palette.
The screen modes are as follows:
SCREEN 0    Text mode
            80x25 or 40x25 characters of 8x16 pixels
            16 attributes picked from 64 colours
            Attributes 16-31 are blinking versions of 0-15
            4 pages [ega]
SCREEN 1    CGA colour
            320x200 pixels
            40x25 characters of 8x8 pixels
            4 attributes picked from 16 colours; 2 bits per pixel    
            1 page [ega] 2 pages [pcjr/tandy]
SCREEN 2    CGA monochrome
            640x200 pixels
            80x25 characters of 8x8 pixels
            2 attributes picked from 16 colours; 1 bit per pixel    
            1 page [ega] 2 pages [pcjr/tandy]
SCREEN 3    [pcjr/tandy only] low-res 16-colour
            160x200 pixels
            20x25 characters of 8x8 pixels
            16 attributes picked from 16 colours; 4 bits per pixel
            2 pages
SCREEN 3    [hercules only]
            720x348 pixels
            80x25 characters of 9x14 pixels (with bottom line truncated by 2 px)
            2 attributes; 1 bit per pixel
            2 pages
SCREEN 3--255 [olivetti only]
            640x400 pixels
            80x25 characters of 8x16 pixels
            2 attributes of which one picked from 16 colours; 2 bits per pixel
            1 page            
SCREEN 4    [pcjr/tandy only] med-res 4-colour
            320x200 pixels
            40x25 characters of 8x8 pixels
            4 attributes picked from 16 colours; 2 bits per pixel
            2 pages
SCREEN 5    [pcjr/tandy only] med-res 16-colour
            320x200 pixels
            40x25 characters of 8x8 pixels
            16 attributes picked from 16 colours; 4 bits per pixel
            1 page
SCREEN 6    [pcjr/tandy only] high-res 4-colour
            640x200 pixels
            80x25 characters of 8x8 pixels
            4 attributes picked from 16 colours; 2 bits per pixel
            1 page
SCREEN 7    [ega only] EGA colour
            320x200 pixels
            40x25 characters of 8x8 pixels
            16 attributes picked from 16 colours; 4 bits per pixel    
            8 pages
SCREEN 8    [ega only] EGA colour
            640x200 pixels
            80x25 characters of 8x8 pixels
            16 attributes picked from 16 colours; 4 bits per pixel    
            4 pages
SCREEN 9    [ega only] EGA colour
            640x350 pixels
            80x25 characters of 8x14 pixels
            16 attributes picked from 64 colours; 4 bits per pixel    
            2 pages
SCREEN 10   [ega only, with monitor=mono] EGA monochrome
            640x350 pixels
            80x25 characters of 8x14 pixels
            4 attributes picked from 9 pseudocolours; 2 bits per pixel    
            2 pages


DEVICES
-------
PC-BASIC recognises the following DOS-style devices, which can be opened, input
from and output to much like normal files. 
device      allowed modes   description
SCRN:       OUTPUT          The screen. Output to SCRN: has largely the same 
                            effect as straight output using PRINT. A difference
                            is the WIDTH setting which is independent of the 
                            real screen width.
KYBD:       INPUT           The keyboard. Input read from KYBD: is not echoed 
                            to the screen. Special keys like arrow keys are
                            registered differently than when using INPUT or
                            INPUT$ straight (see the keyword reference).
LPT1:       OUTPUT          Parallel ports 1--3. These are usually used to 
LPT2:                       connect a printer. In PC-BASIC, output to the LPT
LPT3:                       ports can be redirected to a printer connected to 
                            the OS or to a text file. Direct access of the 
                            parallel port is not implemented.
COM1:       INPUT, OUTPUT,  Serial ports 1--2. In PC-BASIC 3.23, direct access
COM2:       APPEND, <code>RANDOM</code>  of the serial port is allowed; alternatively, i/o
                            can be redirected through a UNIX socket or a text
                            file.                   
CONS:       OUTPUT          The screen (console). Output to CONS is displayed 
                            directly at the cursor position when <code><b>Enter</b></code> is 
                            pressed. It does not update the end-of-line value
                            for the interpreter, which means that it does not 
                            move with <BACKSPACE> or <code><b>Del</b></code> and is not 
                            stored in program lines if it appears beyond the 
                            end of the existing line. CONS: can be opened with
                            any access mode, but the effect is always to open 
                            it for OUTPUT. This device is not implemented in 
                            PC-BASIC 3.23.                             
CAS1:       INPUT, OUTPUT   Cassette tape driver. This device is not 
                            implemented in PC-BASIC 3.23. 
                                                            

KEYWORD LIST
------------
Not all keywords are statements or functions; some parts of statement or 
function syntax are not keywords. The relevance of this is that keywords are 
not legal variable names. Therefore, you cannot name a variable TO! but you can
name it AS!. The keywords are here listed with the bytecode token used to 
represent them in a BASIC file.
<pre>
 81 END     82 FOR     83 NEXT    84 DATA    85 INPUT   86 DIM     87 READ  
 88 LET     89 GOTO    8A RUN     8B IF      8C RESTORE 8D <code>GOSUB</code>   8E <code>RETURN</code>
 8F REM     90 STOP    91 PRINT   92 CLEAR   93 LIST    94 NEW     95 ON  
 96 WAIT    97 DEF     98 POKE    99 CONT    9C OUT     9D LPRINT  9E LLIST  
 A0 WIDTH   A1 ELSE    A2 TRON    A3 TROFF   A4 SWAP    A5 ERASE   A6 EDIT  
 A7 ERROR   A8 RESUME  A9 DELETE  AA AUTO    AB RENUM   AC DEFSTR  AD DEFINT  
 AE DEFSNG  AF DEFDBL  B0 LINE    B1 WHILE   B2 WEND    B3 CALL    B7 WRITE  
 B8 OPTION B9 RANDOMIZE BA OPEN   BB CLOSE   BC LOAD    BD <code>MERGE</code>   BE SAVE      
 BF COLOR   C0 CLS     C1 MOTOR   C2 BSAVE   C3 BLOAD   C4 SOUND   C5 BEEP
 C6 PSET    C7 PRESET  C8 SCREEN  C9 KEY     CA LOCATE  CC TO      CD THEN  
 CE TAB(    CF STEP    D0 USR     D1 FN      D2 SPC(    D3 NOT     D4 ERL
 D5 ERR     D6 STRING$ D7 USING   D8 INSTR   D9 '       DA VARPTR  DB CSRLIN  
 DC POINT   DD OFF     DE INKEY$  E6 &gt;       E7 =       E8 &lt;       E9 + 
 EA -       EB *       EC /       ED ^       EE AND     EF OR      F0 XOR  
 F1 EQV     F2 IMP     F3 MOD     F4 \
 FD81 CVI     FD82 CVS     FD83 CVD     FD84 MKI$    FD85 MKS$    FD86 MKD$
 FD8B EXTERR  FE81 FILES   FE82 FIELD   FE83 SYSTEM  FE84 NAME    FE85 LSET  
 FE86 RSET    FE87 KILL    FE88 PUT     FE89 GET     FE8A RESET   FE8B <code>COMMON</code>
 FE8C CHAIN   FE8D DATE$   FE8E TIME$   FE8F PAINT   FE90 COM     FE91 CIRCLE 
 FE92 DRAW    FE93 PLAY    FE94 TIMER   FE95 ERDEV   FE96 IOCTL   FE97 CHDIR 
 FE98 MKDIR   FE99 RMDIR   FE9A SHELL   FE9B ENVIRON FE9C VIEW    FE9D WINDOW
 FE9E PMAP    FE9F PALETTE FEA0 LCOPY   FEA1 CALLS   FEA5 PCOPY 
 FEA7 LOCK    FEA8 UNLOCK  FF81 LEFT$   FF82 RIGHT$  FF83 MID$    FF84 SGN    
 FF85 INT     FF86 ABS     FF87 SQR     FF88 RND     FF89 SIN     FF8A LOG   
 FF8B EXP     FF8C COS     FF8D TAN     FF8E ATN     FF8F FRE     FF90 INP   
 FF91 POS     FF92 LEN     FF93 STR$    FF94 VAL     FF95 ASC     FF96 CHR$   
 FF97 PEEK    FF98 SPACE$  FF99 OCT$    FF9A HEX$    FF9B LPOS    FF9C CINT  
 FF9D CSNG    FF9E CDBL    FF9F FIX     FFA0 PEN     FFA1 STICK   FFA2 STRIG  
 FFA3 EOF     FFA4 LOC     FFA5 LOF          
</pre>
<h4>Notes</h4>
-   If PC-BASIC 3.23 is run with the --debug flag, the following additional 
    keyword is reserved, which is not present in standard versions of GW-BASIC:
        FFFF DEBUG
    When the --debug flag is specified, variable names like DEBUG$ are not 
    allowed.
-   On the IBM PCjr's Cartridge BASIC and Tandy 1000 GW-BASIC, some additional 
    keywords were present. They can be activated using the --syntax=pcjr or 
    --syntax=tandy command-line option:
        FEA4 NOISE   FEA6 TERM
-   Note that they are not currently implemented as statements. 
    When ---syntax=pcjr or --syntax=tandy is specified, these words are not 
    valid variable names and will be correctly transcribed in a listing.

